

We have implemented our algorithms as a part of $\zthree$~\cite{z3} SMT solver\footnote{\url{https://github.com/rahuljain1989/Bit-vector-multiplication-pattern}}.
%
 We evaluate the performance of our algorithms using benchmarks that are industrial and handcrafted hardware verification problems.
%
We compare our tool with $\zthree$, $\boolector$\cite{boolector} and $\cvcfour$\cite{cvc4}.
%
Our experiments show that the solvers time out on most of the benchmarks and our tool produces results within the set time limit.

\paragraph{\bf Implementation}
We implemented the algorithms inside $\zthree$. We have added about 1500 lines of code in the bit vector rewrite module because it allows an easy access to the abstract syntax tree of the input formula.
%
An important aspect of the implementation is the ability to exit as early as possible if the match is going to fail.
%
We implemented various preliminary checks including the ones mentioned in Algorithm 1. We ensure that the size of $\Lambda_i$ is upper bounded appropriately as per the scheme of long multiplication. We exit as soon as the upper bound is violated. 
%
We have implemented three version of $\ourtool$ by varying
$\textsc{SMTSolver}$.
%
We used  $\zthree$, $\boolector$, and $\cvcfour$ for the variations. 
%
In the case of $\zthree$,
we insert the learned tautologies in the $\zthree$ solver within the current execution.
%
For $\boolector$ and $\cvcfour$,
we forcefully stop the $\zthree$ solver after running our matching algorithms,
print the learned tautologies in a file along with the input formula, and
run the solvers in a separate process on the newly generated formula. We use the following versions of the solvers: $\zthree$(4.4.2), $\boolector$(2.2.0), $\cvcfour$(1.4).
% %
% The mode allows us to run the other solvers 

\paragraph{\bf Benchmarks}
%
Our experiments include 14 benchmarks.
%
Initially, we received an industrial hardware verification benchmark in $\sysver$ involving long multiplication that was not solved by any of the solvers in 24 hours.
%
The example inspired our current work and to evaluate it we generated several similar benchmarks.
%
For long multiplication, we generated benchmarks by varying three characteristics, firstly the total bit length of the input bit-vectors, secondly the width of each block, and thirdly assigning specific blocks as equal or set them to zero.
%
Our $\sysver$ benchmarks are fed to STEWord~\cite{Word-level-Symbolic-Trajectory-Evaluation}, a hardware verification tool.
%
STEWord takes $\sysver$ design as input and generates the corresponding SMT1 formula.
%
We convert the SMT1 formula to SMT2 format using $\boolector$.
%
In the process, $\boolector$ extensively simplifies the input formula but retains the overall structure.
%
We have generated benchmarks also for Wallace tree multiplier similar to the long multiplication.
%
For $n$-bit Wallace tree multiplier, we have written a script that takes $n$ as input and generates all the files needed as input by STEWord.
%

\paragraph{\bf Results}
%
We compare our tool with $\zthree$, $\boolector$ and $\cvcfour$. Tables 1-2 present the results of the experiments. We chose timeout to be 600 seconds.
%
\input{tbl-long-time}

In table 1 we present the results of the long multiplication experiments. The columns under $\textsc{SMTSolver}$ are the run times of the solvers to prove the satisfiability of the input benchmark. The solvers timout on most of the benchmarks. 

The last three columns are the run times of the three versions of $\ourtool$ to prove the satisfiability of the benchmarks.
% columns oursolver - time - using backend solvers -Z3, CVC4, Boolector respectively col. numbers  
%
$\ourtool$ with $\cvcfour$ makes best use of the added tautologies. $\cvcfour$ is quickly able to infer that the input formula and the added tautologies are negations of each other justifying the timings captured. 
$\ourtool$ with $\boolector$ and $\zthree$ does not make the above inference, leading to more running time. $\boolector$ and $\zthree$ resort to bit blasting having not been able to detect the structural similarity. However, the added tautologies help $\boolector$ and $\zthree$ to reduce the search space, after the sat solver is invoked on the bit blasted formula.


\input{tbl-wallace-time}

In table 2 we present the results of the Wallace tree multiplier experiments. Since, the multiplier involves a series of half and full adders, the size of the input formula increases rapidly as the bit vector size increases. Despite the blowup in the formula size, $\ourtool$ with $\zthree$ is quickly able to infer that the input formula and the added tautology are negations of each other. However, $\ourtool$ with $\boolector$ and $\cvcfour$ do not make the inference, leading to larger run times. This is because of the synctactic structure of the learned tautology from our implementation inside $\zthree$. The input formula has `and' and `not' gates as its building blocks, whereas $\zthree$ transforms all `ands' to `ors'. Therefore, the added tautology has no `ands'. The difference in the synctactic structure between the input formula and the added tautology makes it difficult for $\boolector$ and $\cvcfour$ to make the above inference. 

\input{tbl-long-cd}
\input{tbl-wallace-cd}
\paragraph{\bf Observations}
%
One benchmark which shows no improvements within the set time limits is mult\_3\_operands. While all the other benchmarks above check for equality of multiplication of two bit vectors, mult\_3\_operands is an attempt to see if the approach works for multiplication of 3 operands which is carried out as two long multiplications. Our observations indicate that none of the solvers are able to infer the structural similarity based on the two tautologies added for the two long multiplications. We carried out similar experiments involving multiple operands, expressions of the form $X*X + Y*Y$, $X*(Y+Z)$, $(X*(Y*Z))*W$. None of the solvers were able to make use of the added tautologies(one for each long multiplication). The problem seems to be on two fronts: one is that to check equality of two terms, the solvers want exact structural similarity and secondly the infrastructure use one assertion to infer the satisfiability of another does not seem to be well developed. 


%--------------------- DO NOT ERASE BELOW THIS LINE --------------------------

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End:




