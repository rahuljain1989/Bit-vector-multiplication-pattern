
%--------------------- DO NOT ERASE BELOW THIS LINE --------------------------

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End:

We have implemented our algorithms as part of $\zthree$ \cite{z3} SMT solver. The algorithms have been implemented in the Bit Vectors rewrite module of $\zthree$. The benchmarks we use to evaluate the performance of our algorithms have been handcrafted and generated using the tool STEWord \cite{Word-level Symbolic Trajectory Evaluation}. Our initial motivation was drawn from a few examples from the industry. Preliminary results show that most of the leading SMT solvers time out on these benchmarks and our implementation peforms better atleast by a factor of x. We restrict our comparison to Z3, Boolector\cite{Boolector} and CVC4\cite{cvc4}.

Working in the rewrite module was a natural choice as it gives easy access to the formula AST currently looked at. Instead of rewriting the sub-formula matching a pre-specified pattern, we prefer to add new tautologies to help the solver make use of the added tautologies and try to solve the formula. Various preliminary checks are made including the ones described in MatchLong, to ensure early exit and reduce the running time. We capture the new tautologies in two ways, one is by adding the tautologies in the current execution itself and other is by dumping the the tautologies and adding it as a conjunction to the current smt2 formula being looked at. The second approach gives us the flexiblity to run other solvers on on the newly generated smt2 formula and see which solver is able to make best use of the added tautologies.

Benchmarks are either hand crafted or generated using STEWord. STEWord takes System-Verilog design as input and generates the corresponding smt1 formula. We further use Boolector to convert the smt1 formula generated to smt2 format. In the process Boolector extensively simplifies the input formula but retains the overall structure. For long multiplication, benchmarks are generated by varying two parameters. As we know,
the long multiplier breaks down the multiplication of two bit-vectors of size $n = kw$ bits each,
into chunks of $w$ bits each to get the partial products. We vary $n$ and $w$ to get different benchmarks and capture the time taken by the solvers to solve them. Also, we experiment by assigning specific chunks as equal or set them to zero. For $n$-bit Wallace tree multiplier, we have written a generic script which takes $n$ as input and generates all the files needed as input by STEWord. 

We carry out the experiments by running the solvers on the original input formula and the modified formula after adding the new tautologies. For $\zthree$ we also capture the time taken to solve when the tautologies are added during the current execution.

Shorthand, $O$ - original input formula, $M$ - Generated formula, $T$ - trunk version of solver, $CE$ - $\zthree$ - Continue execution after adding tautologies, $bool$ - Boolector.
The tables below specify the results obtained on the various benchmarks. 

\begin{table}[]
\centering
\caption{Long Multiplication}
\label{my-label}
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
Benchmark   & z3 - T,O & z3 - CE & z3 - T,M & bool - T,O & bool - T,M & cvc4 - T,O & cvc4 -T,M \\ \hline
B1 - n bits &          &         &          &            &            &            &           \\ \hline
B2 - n bits &          &         &          &            &            &            &           \\ \hline
B3 - n nits &          &         &          &            &            &            &           \\ \hline
\end{tabular}
\end{table}

Explanation: 

\begin{table}[]
\centering
\caption{Wallace tree multiplier}
\label{my-label}
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
Benchmark   & z3 - T,O & z3 - CE & z3 - T,M & bool - T,O & bool - T,M & cvc4 - T,O & cvc4 -T,M \\ \hline
B1 - n bits &          &         &          &            &            &            &           \\ \hline
B2 - n bits &          &         &          &            &            &            &           \\ \hline
B3 - n nits &          &         &          &            &            &            &           \\ \hline
\end{tabular}
\end{table}

Explanation:

 
