diff --git a/src/ast/rewriter/bv_rewriter.cpp b/src/ast/rewriter/bv_rewriter.cpp
index def05f0..3885c19 100644
--- a/src/ast/rewriter/bv_rewriter.cpp
+++ b/src/ast/rewriter/bv_rewriter.cpp
@@ -1634,6 +1634,1071 @@ br_status bv_rewriter::mk_bv_comp(expr * arg1, expr * arg2, expr_ref & result) {
     return BR_REWRITE2;
 }
 
+void bv_rewriter:: traverse_bvadd_args(expr * cur_arg, vector<expr *> &bv_args)
+{
+   if (m_util.is_concat(cur_arg))
+   {
+       bv_args.push_back(cur_arg);
+   }
+
+   else if (m_util.is_bv_add(cur_arg))
+   {
+       int arg_count = to_app(cur_arg)->get_num_args();
+       for (unsigned i = 0; i < arg_count; i++)
+       {
+           traverse_bvadd_args(to_app(cur_arg)->get_arg(i),bv_args);
+       }
+
+   }
+}
+
+vector <vector <expr *> > left_container_list;
+vector <vector <expr *> > right_container_list;
+
+br_status bv_rewriter::check_pattern(unsigned num_args, expr *const *args,
+                                     expr_ref &result) {
+  // unsigned _num_args;
+  // expr *const *_args;
+  // _num_args = num_args;
+  // _args = args;
+  // vector<expr *> non_concat_args; // To capture all concat arguments
+  // unsigned sz    = get_bv_size(args[0]);
+
+
+  /* // Code to flatten
+  for (unsigned i = 0; i < num_args; i++)
+  {
+     traverse_bvadd_args(args[i], flat_args);
+
+  }
+
+  int flat_args_size = flat_args.size();
+  */
+
+  // Wait for flattening
+  for (unsigned i = 0; i < num_args; i++)
+  {
+      if (m_util.is_bv_add(args[i]))
+      {
+          return BR_FAILED;
+      }
+
+  }
+
+  vector<expr *> flat_args; // To capture all concat arguments
+  for (unsigned i = 0; i < num_args; i++)
+  {
+      flat_args.push_back(args[i]);
+  }
+
+  int flat_args_size = flat_args.size();
+
+  if (flat_args_size <= 4)
+      return BR_FAILED;
+
+  // Every bvarg should be a concat of zeroes and partial products
+  for (unsigned i = 0; i < flat_args_size; i++) {
+      app *cur_add_arg = to_app(flat_args[i]); // current bvadd arg
+      // Every bvarg should be concat
+      if(!m_util.is_concat(cur_add_arg))
+          return BR_FAILED;
+
+      unsigned concat_arg_count =
+          to_app(cur_add_arg)->get_num_args(); // Number of concatenations
+      for (unsigned j = 0; j < concat_arg_count; j++) {
+        expr *concat_arg = to_app(cur_add_arg)->get_arg(j);
+        // Every concat arg should be zero or a bvmul
+        if (!is_zero(concat_arg)  && !m_util.is_bv_mul(concat_arg)) {
+            return BR_FAILED;
+        }
+      }
+  }
+
+  // Code to check feasible number of zeros in every bvadd argument
+
+  app *first_arg = to_app(flat_args[0]); // first bvadd argument
+  unsigned arg_count = to_app(first_arg)->get_num_args();
+  unsigned bvadd_arg_size = get_bv_size(first_arg);
+  unsigned pp_bv_size = 0;
+
+  // Code to get bv size of partial product
+  for (unsigned i = 0; i < arg_count; i++) {
+      expr *concat_arg = to_app(first_arg)->get_arg(i);
+      if (m_util.is_bv_mul(concat_arg)) {
+        pp_bv_size = get_bv_size(concat_arg);
+        break;
+      }
+  }
+
+  // Partial product size should be even as equal number of zeros have to be appended
+  if (pp_bv_size % 2 == 1)
+      return BR_FAILED;
+
+  unsigned const pp_bv_size_half = pp_bv_size/2;
+
+  // Check bv sizes of all partial products and zeros
+
+  for (unsigned i = 0; i < flat_args_size; i++) {
+      app *cur_add_arg = to_app(flat_args[i]); // current bvadd arg
+      unsigned concat_arg_count =
+          to_app(cur_add_arg)->get_num_args(); // Number of concatenations
+      for (unsigned j = 0; j < concat_arg_count; j++) {
+        expr *concat_arg = to_app(cur_add_arg)->get_arg(j);
+        if (is_zero(concat_arg)) {
+          unsigned zero_count = get_bv_size(concat_arg);
+          // Number of zeros should always be a multiple of pp_bv_size_half
+          if (zero_count % pp_bv_size_half != 0)
+              return BR_FAILED;
+        }
+
+        // If mul, check if it is same size as captured before
+        // and if each bvmul has enough padding
+        else if (m_util.is_bv_mul(concat_arg)) {
+          unsigned pp_size = get_bv_size(concat_arg);
+          // All partial product sizes should be equal
+          if (pp_size != pp_bv_size)
+              return BR_FAILED;
+          // Check for whether first half of each bvmul arg is zero
+          unsigned bvmul_arg_count =
+              to_app(concat_arg)->get_num_args();
+          if (bvmul_arg_count != 2)
+              return BR_FAILED;
+          for (unsigned i = 0; i < bvmul_arg_count; i++)
+          {
+              expr *bvmul_arg = to_app(concat_arg)->get_arg(i);
+              unsigned sz = get_bv_size(bvmul_arg);
+
+              for (unsigned j = sz/2; j < sz; j++) {
+                  if (!is_zero_bit(bvmul_arg, j))
+                  {
+                      // bad state;
+                      return BR_FAILED;
+                  }
+              }
+          }
+        }
+      }
+  }
+
+
+  /* Now that we know all args have right number of zeros,
+     and same pp bv size, we go through each bvadd arg at a time
+     and collect them in appropriate container
+     */
+
+  vector<expr *> container[30];  // Containers to capture all bvmul args
+
+  for (unsigned i = 0; i < flat_args_size; i++) {
+    app *cur_add_arg = to_app(flat_args[i]); // current bvadd arg
+
+    unsigned concat_arg_count =
+        to_app(cur_add_arg)->get_num_args(); // Number of concatenations
+
+    int pos_count = 0;
+    // Collect all partial products in appropriate container
+    for (unsigned j = 0; j < concat_arg_count; j++) {
+      expr *concat_arg = to_app(cur_add_arg)->get_arg(j);
+
+      // If zero, do nothing, just count position
+      if (is_zero(concat_arg)) {
+        pos_count += get_bv_size(concat_arg);
+      }
+
+      // If mul, collect bvmul in appropriate container
+      else if (m_util.is_bv_mul(concat_arg)) {
+        container[(pos_count / pp_bv_size_half)+1].push_back(
+            to_app(concat_arg));
+        pos_count += get_bv_size(concat_arg);
+      }
+    }
+  }
+
+
+  const unsigned no_of_containers = bvadd_arg_size/pp_bv_size_half;
+  unsigned size;
+
+  // Check max size of containers
+
+  for (unsigned i = 0; i < no_of_containers/2; i++) {
+      size = container[i].size();
+      if (size > i)
+          return BR_FAILED;
+  }
+
+  for (unsigned i = no_of_containers/2; i < no_of_containers; i++) {
+      size = container[i].size();
+      if (size > no_of_containers - i)
+          return BR_FAILED;
+  }
+
+  // Look for the first non empty container
+  unsigned i;
+  for (i = 0; i < no_of_containers; i++)
+  {
+      size = container[i].size();
+      if (size != 0)
+      {
+          break;
+      }
+  }
+
+  if (container[i].size() != 1 || i >= no_of_containers)
+      return BR_FAILED;
+
+  unsigned first_non_empty_container_index = i;
+
+  /* Now that we know the first non empty container, and that it has only
+   * partial product, lets see if both the arguments are same
+   */
+
+  expr *bvmul = container[first_non_empty_container_index][0];
+  expr *bvmul_arg1 = to_app(bvmul)->get_arg(0);
+  expr *bvmul_arg2 = to_app(bvmul)->get_arg(1);
+
+  // bool same_first_args;
+
+  /*
+  if (bvmul_arg1 == bvmul_arg2)
+      same_first_args = true;
+  else
+      same_first_args = false;
+  */
+
+  vector<expr *> left_container; // To capture all lhs arguments
+  vector<expr *> right_container; // To capture all rhs arguments
+
+
+  left_container.push_back(to_app(bvmul_arg1));
+  right_container.push_back(to_app(bvmul_arg2));
+
+  bool check = check_container(no_of_containers,
+                               first_non_empty_container_index,
+                               first_non_empty_container_index+1,
+                               container,
+                               left_container,
+                               right_container
+                               );
+
+  if (!check)
+      return BR_FAILED;
+
+  for (unsigned j = 0; j < left_container_list.size(); j++)
+  {
+      left_container = left_container_list[j];
+      right_container = right_container_list[j];
+      unsigned const left_container_size = left_container.size();
+      unsigned const right_container_size = right_container.size();
+
+      // Should be equal as insertions have been done for both at every point
+      if (left_container_size != right_container_size)
+          return BR_FAILED;
+
+      // TODO - check whether both the below strips need to be done
+      // together.
+
+      // Strip off extra zero args from the right
+      for (signed i = left_container_size - 1; i >= 0; i--)
+      {
+          if (is_zero(left_container[i]))
+          {
+              left_container.erase(left_container.begin() + i);
+          }
+
+          else
+          {
+              break;
+          }
+      }
+
+      for (signed i = right_container_size - 1; i >= 0; i--)
+      {
+          if (is_zero(right_container[i]))
+          {
+              right_container.erase(right_container.begin() + i);
+          }
+
+          else
+          {
+              break;
+          }
+      }
+
+
+
+      // Code to reconstruct the multiplicand and multiplier
+      // Find the number of empty containers on the right
+      unsigned no_of_empty_containers_right = 0;
+
+      for (signed i = no_of_containers - 1; i >= 0; i--)
+      {
+          if (container[i].size() == 0)
+          {
+              no_of_empty_containers_right++;
+          }
+
+          else
+              break;
+      }
+
+      // Calculate number of trailing and leading zero args in m1 and m2
+
+      unsigned const no_of_args = no_of_containers/2;
+      unsigned m1_trailing_zero, m2_trailing_zero;
+      for (unsigned i = 0; i <= no_of_args; i++)
+      {
+          int flag = 0;
+          for (unsigned j = 0; j <= no_of_args; j++)
+          {
+              if((left_container.size() + i <= no_of_args) &&
+                 (left_container.size() + i <= no_of_args) &&
+                 ((i+j) == no_of_empty_containers_right))
+              {
+                  m1_trailing_zero = i;
+                  m2_trailing_zero = j;
+                  flag = 1;
+                  break;
+              }
+          }
+
+          if (flag == 1)
+              break;
+      }
+
+      unsigned m1_leading_zero = no_of_args - left_container.size() - m1_trailing_zero;
+      unsigned m2_leading_zero = no_of_args - right_container.size() - m2_trailing_zero;
+
+
+      // Code to add front zero padding
+      unsigned number_of_front_zeros = pp_bv_size_half * no_of_args;
+      expr * zero_padding = m_util.mk_numeral(numeral(0), number_of_front_zeros);
+
+      vector<expr *> m1;
+      vector<expr *> m2;
+
+      m1.push_back(zero_padding);
+      m2.push_back(zero_padding);
+
+      // Code to add leading zeros
+
+      expr * zero = m_util.mk_numeral(numeral(0), pp_bv_size_half);
+
+      for (unsigned i = 0; i < m1_leading_zero; i++)
+          m1.push_back(zero);
+      for (unsigned i = 0; i < m2_leading_zero; i++)
+          m2.push_back(zero);
+
+      // Code to add m1 and m2 found
+      for (unsigned i = 0; i < left_container.size(); i++)
+      {
+          m1.push_back(m_mk_extract(pp_bv_size_half-1, 0, left_container[i]));
+      }
+
+      for (unsigned i = 0; i < right_container.size(); i++)
+      {
+          m2.push_back(m_mk_extract(pp_bv_size_half-1, 0, right_container[i]));
+      }
+
+      // Code to add trailing zeros
+
+      for (unsigned i = 0; i < m1_trailing_zero; i++)
+          m1.push_back(zero);
+      for (unsigned i = 0; i < m2_trailing_zero; i++)
+          m2.push_back(zero);
+
+      expr *const *l = &m1[0];
+      expr *const *r = &m2[0];
+
+      expr* concat1 = m_util.mk_concat(m1.size(),l);
+      expr* concat2 = m_util.mk_concat(m2.size(),r);
+
+      expr* mul_args[2] = {concat1,concat2};
+      expr *e1 = m().mk_app(get_fid(), OP_BADD, num_args, args);
+      expr *e2 = m().mk_app(get_fid(), OP_BMUL, 2, mul_args);
+      result = m().mk_eq(e1, e2);
+
+      tout << "\n; Adding new assert\n";
+      tout << "(assert";
+      tout << result;
+      tout << ")";
+      tout << "\n\n";
+  }
+
+  exit(1);
+  return BR_FAILED;
+
+  }
+
+int bv_rewriter::check_container(unsigned const no_of_containers,
+                                 unsigned const first_non_empty_container_index,
+                                 unsigned const current_container_index,
+                                 vector<expr *> const (&container)[30],
+                                 vector<expr *> &left_container,
+                                 vector<expr *> &right_container) {
+    // Create a copy of the current container
+
+    if (current_container_index == no_of_containers)
+    {
+        vector<expr *> left_container_copy(left_container);
+        vector<expr *> right_container_copy(right_container);
+        left_container_list.push_back(left_container_copy);
+        right_container_list.push_back(right_container_copy);
+        return 1;
+    }
+
+    vector<expr *> current_container(container[current_container_index]);
+    unsigned int offset = current_container_index - first_non_empty_container_index;
+    unsigned int sz = current_container.size();
+
+    // Remove known partial products from current container
+    for (unsigned i = 1; i <= offset - 1; i++)
+    {
+        expr * l = left_container[i];
+        expr * r = right_container[offset - i];
+
+        unsigned sz = current_container.size();
+
+        if (!is_zero(l) && !is_zero(r))
+        {
+            unsigned flag = 0;
+            for (unsigned j = 0; j < sz; j++)
+            {
+                expr *bvmul = current_container[j];
+                expr *bvmul_arg1 = to_app(bvmul)->get_arg(0);
+                expr *bvmul_arg2 = to_app(bvmul)->get_arg(1);
+
+                if ((l == bvmul_arg1 && r == bvmul_arg2) ||
+                        (l == bvmul_arg2 && r == bvmul_arg1))
+                {
+                    flag = 1;
+                    current_container.erase(current_container.begin() + j);
+                    break;
+                }
+            }
+
+            if (flag == 0)
+                return 0;
+        }
+    }
+
+    // At max two partial products should remain after removing known ones
+    if (current_container.size() > 2)
+    {
+        return 0;
+    }
+
+    sz = current_container.size();
+
+    // Now we look at the different cases based on first argument collected
+    // and the partial products in the current container
+
+    bool const same_first_args = (left_container[0] == right_container[0]);
+    expr * zero = m_util.mk_numeral(numeral(0), get_bv_size(left_container[0]));
+
+    // Case 1: first arguments are different and current container has 2 pps
+    if (!same_first_args && sz == 2)
+    {
+        expr *bvmul1 = current_container[0];
+        expr *bvmul2 = current_container[1];
+        expr *l1 = to_app(bvmul1)->get_arg(0);
+        expr *r1 = to_app(bvmul1)->get_arg(1);
+        expr *l2 = to_app(bvmul2)->get_arg(0);
+        expr *r2 = to_app(bvmul2)->get_arg(1);
+
+        vector<expr *> left_container_copy(left_container);
+        vector<expr *> right_container_copy(right_container);
+
+        // Check whether both first arguments are present in the pps
+
+        bool present = false;
+
+        if (l1 == left_container[0] || r1 == left_container[0])
+        {
+            if (l2 == right_container[0] || r2 == right_container[0])
+            {
+                present = true;
+            }
+        }
+
+        if (l1 == right_container[0] || r1 == right_container[0])
+        {
+            if (l2 == left_container[0] || r2 == left_container[0])
+            {
+                present = true;
+            }
+        }
+
+        // Both first arguments not found
+        if (!present)
+        {
+            return 0;
+        }
+
+        // Now we know both first arguments are present in both the partial
+        // products. We can now look at different subcases
+
+        // Subcase 1: left_container[0] is an argument of bvmul1 and not bvmul2
+
+        if ((l1 == left_container[0] || r1 == left_container[0]) &&
+                !(l2 == left_container[0] || r2 == left_container[0]))
+        {
+            if (l1 == left_container[0])
+                right_container.push_back(to_app(r1));
+            else if (r1 == left_container[0])
+                right_container.push_back(to_app(l1));
+
+            if (l2 == right_container[0])
+                left_container.push_back(to_app(r2));
+            else if (r2 == right_container[0])
+                left_container.push_back(to_app(l2));
+        }
+
+        // Subcase 2: left_container[0] is an argument of bvmul2 and not bvmul1
+
+        else if ((l2 == left_container[0] || r2 == left_container[0]) &&
+                !(l1 == left_container[0] || r1 == left_container[0]))
+        {
+            if (l2 == left_container[0])
+                right_container.push_back(to_app(r2));
+            else if (r2 == left_container[0])
+                right_container.push_back(to_app(l2));
+
+            if (l1 == right_container[0])
+                left_container.push_back(to_app(r1));
+            else if (r1 == right_container[0])
+                left_container.push_back(to_app(l1));
+        }
+
+        // Subcase 3: right_container[0] is an argument of bvmul1 and not bvmul2
+
+        else if ((l1 == right_container[0] || r1 == right_container[0]) &&
+                !(l2 == right_container[0] || r2 == right_container[0]))
+        {
+            if (l1 == right_container[0])
+                left_container.push_back(to_app(r1));
+            else if (r1 == right_container[0])
+                left_container.push_back(to_app(l1));
+
+            if (l2 == left_container[0])
+                right_container.push_back(to_app(r2));
+            else if (r2 == left_container[0])
+                right_container.push_back(to_app(l2));
+        }
+
+        // Subcase 4: right_container[0] is an argument of bvmul2 and not bvmul1
+
+        else if ((l2 == right_container[0] || r2 == right_container[0]) &&
+                !(l1 == right_container[0] || r1 == right_container[0]))
+        {
+            if (l2 == right_container[0])
+                left_container.push_back(to_app(r2));
+            else if (r2 == right_container[0])
+                left_container.push_back(to_app(l2));
+
+            if (l1 == left_container[0])
+                right_container.push_back(to_app(r1));
+            else if (r1 == left_container[0])
+                right_container.push_back(to_app(l1));
+        }
+
+        // Subcase 5: Both first arguments are present in both bvmul1 and bvmul2
+        // if a and b are the first arguments, bvmul1 and bvmul2 are both a * b
+
+        else if ((l1 == left_container[0] || r1 == left_container[0]) &&
+                 (l2 == left_container[0] || r2 == left_container[0]) &&
+                 (l2 == right_container[0] || r2 == right_container[0]) &&
+                 (l1 == right_container[0] || r1 == right_container[0]))
+        {
+            left_container.push_back(left_container[0]);
+            right_container.push_back(right_container[0]);
+        }
+
+        bool check = check_container(no_of_containers,
+                                     first_non_empty_container_index,
+                                     current_container_index+1,
+                                     container,
+                                     left_container,
+                                     right_container
+                                     );
+        if (check)
+            return 1;
+        else
+        {
+            left_container = left_container_copy;
+            right_container = right_container_copy;
+            return 0;
+        }
+
+    }
+
+    // Case 2: first arguments are same and current container has 2 pps
+    else if (same_first_args && sz == 2)
+    {
+        expr *bvmul1 = current_container[0];
+        expr *bvmul2 = current_container[1];
+        expr *l1 = to_app(bvmul1)->get_arg(0);
+        expr *r1 = to_app(bvmul1)->get_arg(1);
+        expr *l2 = to_app(bvmul2)->get_arg(0);
+        expr *r2 = to_app(bvmul2)->get_arg(1);
+
+        // Check whether first argument is present in both bvmuls
+
+        bool present = false;
+
+        if (l1 == left_container[0] || r1 == left_container[0])
+        {
+            if (l2 == left_container[0] || r2 == left_container[0])
+            {
+                present = true;
+            }
+        }
+
+        // First argument not present in both bvmuls
+        if (!present)
+        {
+            return 0;
+        }
+
+        // Subcase 1
+        if (l1 == left_container[0] && l2 == left_container[0])
+        {
+            vector<expr *> left_container_copy(left_container);
+            vector<expr *> right_container_copy(right_container);
+            left_container.push_back(r1);
+            right_container.push_back(r2);
+
+            bool check1 = check_container(no_of_containers,
+                                         first_non_empty_container_index,
+                                         current_container_index+1,
+                                         container,
+                                         left_container,
+                                         right_container
+                                         );
+            if (false)
+                return 1;
+            else
+            {
+                left_container = left_container_copy;
+                right_container = right_container_copy;
+                left_container.push_back(r2);
+                right_container.push_back(r1);
+                bool check2 = check_container(no_of_containers,
+                                             first_non_empty_container_index,
+                                             current_container_index+1,
+                                             container,
+                                             left_container,
+                                             right_container
+                                             );
+                if (check1 || check2)
+                    return 1;
+                else
+                {
+                    left_container = left_container_copy;
+                    right_container = right_container_copy;
+                    return 0;
+                }
+
+            }
+        }
+
+        // Subcase 2
+        else if (r1 == left_container[0] && r2 == left_container[0])
+        {
+            vector<expr *> left_container_copy(left_container);
+            vector<expr *> right_container_copy(right_container);
+            left_container.push_back(l1);
+            right_container.push_back(l2);
+
+            bool check1 = check_container(no_of_containers,
+                                         first_non_empty_container_index,
+                                         current_container_index+1,
+                                         container,
+                                         left_container,
+                                         right_container
+                                         );
+            if (false)
+                return 1;
+            else
+            {
+                left_container = left_container_copy;
+                right_container = right_container_copy;
+                left_container.push_back(l2);
+                right_container.push_back(l1);
+                bool check2 = check_container(no_of_containers,
+                                             first_non_empty_container_index,
+                                             current_container_index+1,
+                                             container,
+                                             left_container,
+                                             right_container
+                                             );
+                if (check1 || check2)
+                    return 1;
+                else
+                {
+                    left_container = left_container_copy;
+                    right_container = right_container_copy;
+                    return 0;
+                }
+
+            }
+        }
+
+        // Subcase 3
+        else if (l1 == left_container[0] && r2 == left_container[0])
+        {
+            vector<expr *> left_container_copy(left_container);
+            vector<expr *> right_container_copy(right_container);
+            left_container.push_back(l2);
+            right_container.push_back(r1);
+
+            bool check1 = check_container(no_of_containers,
+                                         first_non_empty_container_index,
+                                         current_container_index+1,
+                                         container,
+                                         left_container,
+                                         right_container
+                                         );
+            if (false)
+                return 1;
+            else
+            {
+                left_container = left_container_copy;
+                right_container = right_container_copy;
+                left_container.push_back(r1);
+                right_container.push_back(l2);
+                bool check2 = check_container(no_of_containers,
+                                             first_non_empty_container_index,
+                                             current_container_index+1,
+                                             container,
+                                             left_container,
+                                             right_container
+                                             );
+                if (check1 || check2)
+                    return 1;
+                else
+                {
+                    left_container = left_container_copy;
+                    right_container = right_container_copy;
+                    return 0;
+                }
+
+            }
+        }
+
+        // Subcase 4
+        else if (r1 == left_container[0] && l2 == left_container[0])
+        {
+            vector<expr *> left_container_copy(left_container);
+            vector<expr *> right_container_copy(right_container);
+            left_container.push_back(l1);
+            right_container.push_back(r2);
+
+            bool check1 = check_container(no_of_containers,
+                                         first_non_empty_container_index,
+                                         current_container_index+1,
+                                         container,
+                                         left_container,
+                                         right_container
+                                         );
+            if (false)
+                return 1;
+            else
+            {
+                left_container = left_container_copy;
+                right_container = right_container_copy;
+                left_container.push_back(r2);
+                right_container.push_back(l1);
+                bool check2 = check_container(no_of_containers,
+                                             first_non_empty_container_index,
+                                             current_container_index+1,
+                                             container,
+                                             left_container,
+                                             right_container
+                                             );
+                if (check1 || check2)
+                    return 1;
+                else
+                {
+                    left_container = left_container_copy;
+                    right_container = right_container_copy;
+                    return 0;
+                }
+
+            }
+        }
+    }
+
+    // Case 3: first arguments are different and current container has 1 pps
+    else if (!same_first_args && sz == 1)
+    {
+        expr *bvmul = current_container[0];
+        expr *l = to_app(bvmul)->get_arg(0);
+        expr *r = to_app(bvmul)->get_arg(1);
+
+        // Check whether any one of the first arguments is present in bvmul
+        if (!(l == left_container[0] || r == left_container[0] ||
+              l == right_container[0] || r == right_container[0]))
+            return 0;
+
+        // Subcase 1: Both bvmul args are first arguments
+
+        if ((l == left_container[0] && r == right_container[0]) ||
+            (r == left_container[0] && l == right_container[0]))
+        {
+            if (l == left_container[0] && r == right_container[0])
+            {
+                vector<expr *> left_container_copy(left_container);
+                vector<expr *> right_container_copy(right_container);
+                left_container.push_back(l);
+                right_container.push_back(zero);
+
+                bool check1 = check_container(no_of_containers,
+                                             first_non_empty_container_index,
+                                             current_container_index+1,
+                                             container,
+                                             left_container,
+                                             right_container
+                                             );
+                if (false)
+                    return 1;
+                else
+                {
+                    left_container = left_container_copy;
+                    right_container = right_container_copy;
+                    left_container.push_back(zero);
+                    right_container.push_back(r);
+                    bool check2 = check_container(no_of_containers,
+                                                 first_non_empty_container_index,
+                                                 current_container_index+1,
+                                                 container,
+                                                 left_container,
+                                                 right_container
+                                                 );
+                    if (check1 || check2)
+                        return 1;
+                    else
+                    {
+                        left_container = left_container_copy;
+                        right_container = right_container_copy;
+                        return 0;
+                    }
+                }
+            }
+
+            else if (r == left_container[0] && l == right_container[0])
+            {
+                vector<expr *> left_container_copy(left_container);
+                vector<expr *> right_container_copy(right_container);
+                left_container.push_back(r);
+                right_container.push_back(zero);
+
+                bool check1 = check_container(no_of_containers,
+                                             first_non_empty_container_index,
+                                             current_container_index+1,
+                                             container,
+                                             left_container,
+                                             right_container
+                                             );
+                if (false)
+                    return 1;
+                else
+                {
+                    left_container = left_container_copy;
+                    right_container = right_container_copy;
+                    left_container.push_back(zero);
+                    right_container.push_back(l);
+                    bool check2 = check_container(no_of_containers,
+                                                 first_non_empty_container_index,
+                                                 current_container_index+1,
+                                                 container,
+                                                 left_container,
+                                                 right_container
+                                                 );
+                    if (check1 || check2)
+                        return 1;
+                    else
+                    {
+                        left_container = left_container_copy;
+                        right_container = right_container_copy;
+                        return 0;
+                    }
+
+                }
+            }
+
+        }
+
+        // Subcase 2: Only one bvmul arg is first argument
+        else
+        {
+            vector<expr *> left_container_copy(left_container);
+            vector<expr *> right_container_copy(right_container);
+
+            if (l == left_container[0])
+            {
+            left_container.push_back(zero);
+            right_container.push_back(r);
+            }
+
+            else if (r == left_container[0])
+            {
+            left_container.push_back(zero);
+            right_container.push_back(l);
+            }
+
+            else if (l == right_container[0])
+            {
+            left_container.push_back(r);
+            right_container.push_back(zero);
+            }
+
+            else if (r == right_container[0])
+            {
+            left_container.push_back(l);
+            right_container.push_back(zero);
+            }
+
+            bool check = check_container(no_of_containers,
+                                         first_non_empty_container_index,
+                                         current_container_index+1,
+                                         container,
+                                         left_container,
+                                         right_container
+                                         );
+            if (check)
+                return 1;
+            else
+            {
+                left_container = left_container_copy;
+                right_container = right_container_copy;
+                return 0;
+            }
+        }
+
+    }
+
+    // Case 4: first arguments are same and current container has 1 pps
+    else if (same_first_args && sz == 1)
+    {
+        expr *bvmul = current_container[0];
+        expr *l = to_app(bvmul)->get_arg(0);
+        expr *r = to_app(bvmul)->get_arg(1);
+
+        // Check whether first argument is present in bvmul
+        if (!(l == left_container[0] || r == left_container[0]))
+            return 0;
+
+        if (l == left_container[0])
+        {
+            vector<expr *> left_container_copy(left_container);
+            vector<expr *> right_container_copy(right_container);
+            left_container.push_back(r);
+            right_container.push_back(zero);
+
+            bool check1 = check_container(no_of_containers,
+                                         first_non_empty_container_index,
+                                         current_container_index+1,
+                                         container,
+                                         left_container,
+                                         right_container
+                                         );
+            if (false)
+                return 1;
+            else
+            {
+                left_container = left_container_copy;
+                right_container = right_container_copy;
+                left_container.push_back(zero);
+                right_container.push_back(r);
+                bool check2 = check_container(no_of_containers,
+                                             first_non_empty_container_index,
+                                             current_container_index+1,
+                                             container,
+                                             left_container,
+                                             right_container
+                                             );
+                if (check1 || check2)
+                    return 1;
+                else
+                {
+                    left_container = left_container_copy;
+                    right_container = right_container_copy;
+                    return 0;
+                }
+            }
+        }
+
+        else if (r == left_container[0])
+        {
+            vector<expr *> left_container_copy(left_container);
+            vector<expr *> right_container_copy(right_container);
+            left_container.push_back(l);
+            right_container.push_back(zero);
+
+            bool check1 = check_container(no_of_containers,
+                                         first_non_empty_container_index,
+                                         current_container_index+1,
+                                         container,
+                                         left_container,
+                                         right_container
+                                         );
+            if (false)
+                return 1;
+            else
+            {
+                left_container = left_container_copy;
+                right_container = right_container_copy;
+                right_container.push_back(l);
+                left_container.push_back(zero);
+                bool check2 = check_container(no_of_containers,
+                                             first_non_empty_container_index,
+                                             current_container_index+1,
+                                             container,
+                                             left_container,
+                                             right_container
+                                             );
+                if (check1 || check2)
+                    return 1;
+                else
+                {
+                    left_container = left_container_copy;
+                    right_container = right_container_copy;
+                    return 0;
+                }
+
+            }
+        }
+    }
+
+    // Case 5: current container has 0 pps
+    else if (sz == 0)
+    {
+        vector<expr *> left_container_copy(left_container);
+        vector<expr *> right_container_copy(right_container);
+
+        left_container.push_back(zero);
+        right_container.push_back(zero);
+        bool check = check_container(no_of_containers,
+                                     first_non_empty_container_index,
+                                     current_container_index+1,
+                                     container,
+                                     left_container,
+                                     right_container
+                                     );
+        if (check)
+            return 1;
+        else
+        {
+            left_container = left_container_copy;
+            right_container = right_container_copy;
+            return 0;
+        }
+    }
+
+
+    return 0;
+}
+
+
 br_status bv_rewriter::mk_bv_add(unsigned num_args, expr * const * args, expr_ref & result) {
     br_status st = mk_add_core(num_args, args, result);
     if (st != BR_FAILED && st != BR_DONE)
@@ -1682,6 +2747,11 @@ br_status bv_rewriter::mk_bv_add(unsigned num_args, expr * const * args, expr_re
     }
     if (_num_args < 2)
         return st;
+
+ st = check_pattern(num_args, args, result);
+    if (st != BR_FAILED && st != BR_DONE)
+        return st;
+
     unsigned sz = get_bv_size(_args[0]);
     for (unsigned i = 0; i < sz; i++) {
         bool found_non_zero = false;
diff --git a/src/ast/rewriter/bv_rewriter.h b/src/ast/rewriter/bv_rewriter.h
index 7135c52..9ce4c71 100644
--- a/src/ast/rewriter/bv_rewriter.h
+++ b/src/ast/rewriter/bv_rewriter.h
@@ -89,6 +89,15 @@ class bv_rewriter : public poly_rewriter<bv_rewriter_core> {
     br_status mk_bv_ext_rotate_left(expr * arg1, expr * arg2, expr_ref & result);
     br_status mk_bv_ext_rotate_right(expr * arg1, expr * arg2, expr_ref & result);
     br_status mk_bv_add(unsigned num_args, expr * const * args, expr_ref & result);
+    br_status check_pattern(unsigned num_args, expr *const *args, expr_ref &result);
+    void traverse_bvadd_args(expr * cur_arg, vector<expr *> &bv_args);
+    int check_container(const unsigned no_of_containers,
+                        const unsigned first_non_empty_container_index,
+                        const unsigned current_container_index,
+                        vector<expr *> const (&container)[30],
+                        vector<expr *> &left_container,
+                        vector<expr *> &right_container);
+
     br_status mk_bv_add(expr * arg1, expr * arg2, expr_ref & result) {
         expr * args[2] = { arg1, arg2 };
         return mk_bv_add(2, args, result);
