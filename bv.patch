diff --git a/src/ast/rewriter/bv_rewriter.cpp b/src/ast/rewriter/bv_rewriter.cpp
index def05f0..a4b0546 100644
--- a/src/ast/rewriter/bv_rewriter.cpp
+++ b/src/ast/rewriter/bv_rewriter.cpp
@@ -1634,6 +1634,207 @@ br_status bv_rewriter::mk_bv_comp(expr * arg1, expr * arg2, expr_ref & result) {
     return BR_REWRITE2;
 }
 
+void bv_rewriter:: traverse_bvadd_args(expr * cur_arg, vector<expr *> &bv_args)
+{
+   if (m_util.is_concat(cur_arg))
+   {
+       bv_args.push_back(cur_arg);
+   }
+
+   else if (m_util.is_bv_add(cur_arg))
+   {
+       int arg_count = to_app(cur_arg)->get_num_args();
+       for (unsigned i = 0; i < arg_count; i++)
+       {
+           traverse_bvadd_args(to_app(cur_arg)->get_arg(i),bv_args);
+       }
+
+   }
+}
+
+br_status bv_rewriter::check_pattern(unsigned num_args, expr *const *args,
+                                     expr_ref &result) {
+  // unsigned _num_args;
+  // expr *const *_args;
+  // _num_args = num_args;
+  // _args = args;
+
+  vector<expr *> container[8];  // Containers to capture all bvmul args
+  vector<expr *> left_container; // To capture all lhs arguments
+  vector<expr *> right_container; // To capture all rhs arguments
+  vector<expr *> flat_args; // To capture all concat arguments
+  vector<expr *> non_concat_args; // To capture all concat arguments
+
+
+  // unsigned sz    = get_bv_size(args[0]);
+
+  /* // Code to flatten
+  for (unsigned i = 0; i < num_args; i++)
+  {
+     traverse_bvadd_args(args[i], flat_args);
+
+  }
+
+  int flat_args_size = flat_args.size();
+  */
+
+  // Wait for flattening
+  for (unsigned i = 0; i < num_args; i++)
+  {
+      if (m_util.is_bv_add(args[i]))
+      {
+          return BR_FAILED;
+      }
+
+  }
+
+  for (unsigned i = 0; i < num_args; i++)
+  {
+      flat_args.push_back(args[i]);
+  }
+
+  int flat_args_size = flat_args.size();
+
+  if (flat_args_size <= 4)
+      return BR_FAILED;
+
+  // Every bvarg should be a concat of zeroes and partial products
+  for (unsigned i = 0; i < flat_args_size; i++) {
+      app *cur_add_arg = to_app(flat_args[i]); // current bvadd arg
+      // Every bvarg should be concat
+      if(!m_util.is_concat(cur_add_arg))
+          return BR_FAILED;
+
+      unsigned concat_arg_count =
+          to_app(cur_add_arg)->get_num_args(); // Number of concatenations
+      for (unsigned j = 0; j < concat_arg_count; j++) {
+        expr *concat_arg = to_app(cur_add_arg)->get_arg(j);
+        // Every concat arg should be zero or a bvmul
+        if (!is_zero(concat_arg)  && !m_util.is_bv_mul(concat_arg)) {
+            return BR_FAILED;
+        }
+      }
+  }
+
+  // Code to check feasible number of zeros in every bvadd argument
+
+  app *first_arg = to_app(flat_args[0]); // first bvadd argument
+  unsigned arg_count = to_app(first_arg)->get_num_args();
+  unsigned bvadd_arg_size = get_bv_size(first_arg);
+  unsigned pp_bv_size = 0;
+
+  // Code to get bv size of partial product
+  for (unsigned i = 0; i < arg_count; i++) {
+      expr *concat_arg = to_app(first_arg)->get_arg(i);
+      if (m_util.is_bv_mul(concat_arg)) {
+        pp_bv_size = get_bv_size(concat_arg);
+        break;
+      }
+  }
+
+  // Partial product size should be even as equal number of zeros have to be appended
+  if (pp_bv_size % 2 == 1)
+      return BR_FAILED;
+
+  unsigned pp_bv_size_half = pp_bv_size/2;
+
+  // Check bv sizes of all partial products and zeros
+
+  for (unsigned i = 0; i < flat_args_size; i++) {
+      app *cur_add_arg = to_app(flat_args[i]); // current bvadd arg
+      unsigned concat_arg_count =
+          to_app(cur_add_arg)->get_num_args(); // Number of concatenations
+      for (unsigned j = 0; j < concat_arg_count; j++) {
+        expr *concat_arg = to_app(cur_add_arg)->get_arg(j);
+        if (is_zero(concat_arg)) {
+          unsigned zero_count = get_bv_size(concat_arg);
+          // Number of zeros should always be a multiple of pp_bv_size_half
+          if (zero_count % pp_bv_size_half != 0)
+              return BR_FAILED;
+        }
+
+        // If mul, check if it is same size as captured before
+        // and if each bvmul has enough padding
+        else if (m_util.is_bv_mul(concat_arg)) {
+          unsigned pp_size = get_bv_size(concat_arg);
+          // All partial product sizes should be equal
+          if (pp_size != pp_bv_size)
+              return BR_FAILED;
+          // Check for whether first half of each bvmul arg is zero
+          unsigned bvmul_arg_count =
+              to_app(concat_arg)->get_num_args();
+          if (bvmul_arg_count != 2)
+              return BR_FAILED;
+          for (unsigned i = 0; i < bvmul_arg_count; i++)
+          {
+              expr *bvmul_arg = to_app(concat_arg)->get_arg(i);
+              unsigned sz = get_bv_size(bvmul_arg);
+
+              for (unsigned j = sz/2; j < sz; j++) {
+                  if (!is_zero_bit(bvmul_arg, j))
+                  {
+                      // bad state;
+                      return BR_FAILED;
+                  }
+              }
+          }
+        }
+      }
+  }
+
+
+  /* Now that we know all args have right number of zeros,
+     and same pp bv size, we go through each bvadd arg at a time
+     and collect them in appropriate container
+     */
+
+  for (unsigned i = 0; i < flat_args_size; i++) {
+    app *cur_add_arg = to_app(flat_args[i]); // current bvadd arg
+
+    unsigned concat_arg_count =
+        to_app(cur_add_arg)->get_num_args(); // Number of concatenations
+
+    int pos_count = 0;
+    // Collect all partial products in appropriate container
+    for (unsigned j = 0; j < concat_arg_count; j++) {
+      expr *concat_arg = to_app(cur_add_arg)->get_arg(j);
+
+      // If zero, do nothing, just count position
+      if (is_zero(concat_arg)) {
+        pos_count += get_bv_size(concat_arg);
+      }
+
+      // If mul, collect bvmul in appropriate container
+      else if (m_util.is_bv_mul(concat_arg)) {
+        container[(pos_count / pp_bv_size_half)+1].push_back(
+            to_app(concat_arg));
+        pos_count += get_bv_size(concat_arg);
+      }
+    }
+  }
+
+
+  unsigned no_of_containers = bvadd_arg_size/pp_bv_size_half;
+  unsigned size;
+
+  // Check max size of containers
+
+  for (unsigned i = 0; i < no_of_containers/2; i++) {
+      size = container[i].size();
+      if (size > i)
+          return BR_FAILED;
+  }
+
+  for (unsigned i = no_of_containers/2; i < no_of_containers; i++) {
+      size = container[i].size();
+      if (size > no_of_containers - i)
+          return BR_FAILED;
+  }
+
+
+  return BR_FAILED;
+}
+
 br_status bv_rewriter::mk_bv_add(unsigned num_args, expr * const * args, expr_ref & result) {
     br_status st = mk_add_core(num_args, args, result);
     if (st != BR_FAILED && st != BR_DONE)
@@ -1682,6 +1883,11 @@ br_status bv_rewriter::mk_bv_add(unsigned num_args, expr * const * args, expr_re
     }
     if (_num_args < 2)
         return st;
+
+ st = check_pattern(num_args, args, result);
+    if (st != BR_FAILED && st != BR_DONE)
+        return st;
+
     unsigned sz = get_bv_size(_args[0]);
     for (unsigned i = 0; i < sz; i++) {
         bool found_non_zero = false;
diff --git a/src/ast/rewriter/bv_rewriter.h b/src/ast/rewriter/bv_rewriter.h
index 7135c52..f63f157 100644
--- a/src/ast/rewriter/bv_rewriter.h
+++ b/src/ast/rewriter/bv_rewriter.h
@@ -89,6 +89,8 @@ class bv_rewriter : public poly_rewriter<bv_rewriter_core> {
     br_status mk_bv_ext_rotate_left(expr * arg1, expr * arg2, expr_ref & result);
     br_status mk_bv_ext_rotate_right(expr * arg1, expr * arg2, expr_ref & result);
     br_status mk_bv_add(unsigned num_args, expr * const * args, expr_ref & result);
+    br_status check_pattern(unsigned num_args, expr *const *args, expr_ref &result);
+    void traverse_bvadd_args(expr * cur_arg, vector<expr *> &bv_args);
     br_status mk_bv_add(expr * arg1, expr * arg2, expr_ref & result) {
         expr * args[2] = { arg1, arg2 };
         return mk_bv_add(2, args, result);
