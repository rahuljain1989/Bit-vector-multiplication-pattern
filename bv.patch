diff --git a/src/ast/rewriter/bv_rewriter.cpp b/src/ast/rewriter/bv_rewriter.cpp
index def05f0..9ba4d2e 100644
--- a/src/ast/rewriter/bv_rewriter.cpp
+++ b/src/ast/rewriter/bv_rewriter.cpp
@@ -1634,6 +1634,167 @@ br_status bv_rewriter::mk_bv_comp(expr * arg1, expr * arg2, expr_ref & result) {
     return BR_REWRITE2;
 }
 
+void bv_rewriter:: traverse_bvadd_args(expr * cur_arg, vector<expr *> &bv_args)
+{
+   if (m_util.is_concat(cur_arg))
+   {
+       bv_args.push_back(cur_arg);
+   }
+
+   else if (m_util.is_bv_add(cur_arg))
+   {
+       int arg_count = to_app(cur_arg)->get_num_args();
+       for (unsigned i = 0; i < arg_count; i++)
+       {
+           traverse_bvadd_args(to_app(cur_arg)->get_arg(i),bv_args);
+       }
+
+   }
+}
+
+br_status bv_rewriter::check_pattern(unsigned num_args, expr *const *args,
+                                     expr_ref &result) {
+  // unsigned _num_args;
+  // expr *const *_args;
+  // _num_args = num_args;
+  // _args = args;
+
+  vector<expr *> container[7];  // Containers to capture all bvmul args
+  vector<expr *> left_container; // To capture all lhs arguments
+  vector<expr *> right_container; // To capture all rhs arguments
+  vector<expr *> flat_args; // To capture all concat arguments
+  vector<expr *> non_concat_args; // To capture all concat arguments
+
+
+  // unsigned sz    = get_bv_size(args[0]);
+
+  /* // Code to flatten
+  for (unsigned i = 0; i < num_args; i++)
+  {
+     traverse_bvadd_args(args[i], flat_args);
+
+  }
+
+  int flat_args_size = flat_args.size();
+  */
+
+  // Wait for flattening
+  for (unsigned i = 0; i < num_args; i++)
+  {
+      if (m_util.is_bv_add(args[i]))
+      {
+          return BR_FAILED;
+      }
+
+  }
+
+  for (unsigned i = 0; i < num_args; i++)
+  {
+      flat_args.push_back(args[i]);
+  }
+
+  int flat_args_size = flat_args.size();
+
+  if (flat_args_size <= 4)
+      return BR_FAILED;
+
+  // Code to check feasible number of zeros in every bvadd argument
+
+  app *first_arg = to_app(flat_args[0]); // first bvadd argument
+  unsigned arg_count = to_app(first_arg)->get_num_args();
+  unsigned pp_bv_size = 0;
+
+  // Code to get bv size of partial product
+  for (unsigned i = 0; i < arg_count; i++) {
+      expr *concat_arg = to_app(first_arg)->get_arg(i);
+      if (m_util.is_bv_mul(concat_arg)) {
+      pp_bv_size = get_bv_size(concat_arg);
+      break;
+      }
+  }
+
+  // Partial product size should be even as equal number of zeros have to be appended
+  if (pp_bv_size % 2 == 1)
+      return BR_FAILED;
+
+  unsigned pp_bv_size_half = pp_bv_size/2;
+
+  // Check bv sizes of all partial products and zeros
+
+  for (unsigned i = 0; i < flat_args_size; i++) {
+      app *cur_add_arg = to_app(flat_args[i]); // current bvadd arg
+      unsigned concat_arg_count =
+          to_app(cur_add_arg)->get_num_args(); // Number of concatenations
+      for (unsigned j = 0; j < concat_arg_count; j++) {
+        expr *concat_arg = to_app(cur_add_arg)->get_arg(j);
+        if (is_zero(concat_arg)) {
+          unsigned zero_count = get_bv_size(concat_arg);
+          // Number of zeros should always be a multiple of pp_bv_size_half
+          if (zero_count % pp_bv_size_half != 0)
+              return BR_FAILED;
+        }
+
+        // If mul, collect args of mul in appropriate container
+        else if (m_util.is_bv_mul(concat_arg)) {
+          unsigned pp_size = get_bv_size(concat_arg);
+          // All partial product sizes should be equal
+          if (pp_size != pp_bv_size)
+              return BR_FAILED;
+        }
+      }
+  }
+
+
+
+
+
+
+  // Now that we know all args have right number of zeros,
+  // and same pp bv size, we go through each bvadd arg at a time
+
+  for (unsigned i = 0; i < flat_args_size; i++) {
+    app *cur_add_arg = to_app(flat_args[i]); // current bvadd arg
+
+    if (m_util.is_concat(cur_add_arg)) {
+      expr *concat_args[5];                      // Individual concat elements
+      unsigned concat_args_size[5] = {0, 0, 0, 0, 0}; // Size of each concatenation
+      unsigned concat_arg_count =
+          to_app(cur_add_arg)->get_num_args(); // Number of concatenations
+
+      // Collect individual concat elements and their size
+      for (unsigned j = 0; j < concat_arg_count; j++) {
+        concat_args[j] = to_app(cur_add_arg)->get_arg(j);
+        concat_args_size[j] = get_bv_size(concat_args[j]);
+      }
+
+      int pos_count = 0;
+
+      // Collect all partial products in appropriate container
+      for (unsigned j = 0; j < concat_arg_count; j++) {
+        // If zero, do nothing, just count position
+        if (is_zero(concat_args[j])) {
+          pos_count += get_bv_size(concat_args[j]);
+        }
+
+        // If mul, collect args of mul in appropriate container
+        else if (m_util.is_bv_mul(concat_args[j])) {
+          container[pos_count / 2].push_back(
+              to_app(concat_args[j]));
+          pos_count += get_bv_size(concat_args[j]);
+        }
+      }
+    }
+  }
+
+  unsigned size;
+  for (unsigned i = 0; i < 8; i++) {
+      size = container[i].size();
+  }
+
+
+   return BR_FAILED;
+}
+
 br_status bv_rewriter::mk_bv_add(unsigned num_args, expr * const * args, expr_ref & result) {
     br_status st = mk_add_core(num_args, args, result);
     if (st != BR_FAILED && st != BR_DONE)
@@ -1682,6 +1843,11 @@ br_status bv_rewriter::mk_bv_add(unsigned num_args, expr * const * args, expr_re
     }
     if (_num_args < 2)
         return st;
+
+  st = check_pattern(num_args, args, result);
+    if (st != BR_FAILED && st != BR_DONE)
+        return st;
+
     unsigned sz = get_bv_size(_args[0]);
     for (unsigned i = 0; i < sz; i++) {
         bool found_non_zero = false;
diff --git a/src/ast/rewriter/bv_rewriter.h b/src/ast/rewriter/bv_rewriter.h
index 7135c52..f63f157 100644
--- a/src/ast/rewriter/bv_rewriter.h
+++ b/src/ast/rewriter/bv_rewriter.h
@@ -89,6 +89,8 @@ class bv_rewriter : public poly_rewriter<bv_rewriter_core> {
     br_status mk_bv_ext_rotate_left(expr * arg1, expr * arg2, expr_ref & result);
     br_status mk_bv_ext_rotate_right(expr * arg1, expr * arg2, expr_ref & result);
     br_status mk_bv_add(unsigned num_args, expr * const * args, expr_ref & result);
+    br_status check_pattern(unsigned num_args, expr *const *args, expr_ref &result);
+    void traverse_bvadd_args(expr * cur_arg, vector<expr *> &bv_args);
     br_status mk_bv_add(expr * arg1, expr * arg2, expr_ref & result) {
         expr * args[2] = { arg1, arg2 };
         return mk_bv_add(2, args, result);
