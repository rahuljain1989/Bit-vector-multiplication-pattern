diff --git a/src/ast/rewriter/bv_rewriter.cpp b/src/ast/rewriter/bv_rewriter.cpp
index def05f0..c6ea8f4 100644
--- a/src/ast/rewriter/bv_rewriter.cpp
+++ b/src/ast/rewriter/bv_rewriter.cpp
@@ -1634,10 +1634,1611 @@ br_status bv_rewriter::mk_bv_comp(expr * arg1, expr * arg2, expr_ref & result) {
     return BR_REWRITE2;
 }
 
+void bv_rewriter:: traverse_bvadd_args(expr * cur_arg, vector<expr *> &bv_args)
+{
+   if (m_util.is_concat(cur_arg))
+   {
+       bv_args.push_back(cur_arg);
+   }
+
+   else if (m_util.is_bv_add(cur_arg))
+   {
+       int arg_count = to_app(cur_arg)->get_num_args();
+       for (unsigned i = 0; i < arg_count; i++)
+       {
+           traverse_bvadd_args(to_app(cur_arg)->get_arg(i),bv_args);
+       }
+
+   }
+}
+
+vector <vector <expr *> > left_container_list;
+vector <vector <expr *> > right_container_list;
+
+br_status bv_rewriter::check_pattern(unsigned num_args, expr *const *args,
+                                     expr_ref &result) {
+  // unsigned _num_args;
+  // expr *const *_args;
+  // _num_args = num_args;
+  // _args = args;
+  // vector<expr *> non_concat_args; // To capture all concat arguments
+  // unsigned sz    = get_bv_size(args[0]);
+
+
+  /* // Code to flatten
+  for (unsigned i = 0; i < num_args; i++)
+  {
+     traverse_bvadd_args(args[i], flat_args);
+
+  }
+
+  int flat_args_size = flat_args.size();
+  */
+
+    // Wait for flattening
+  for (unsigned i = 0; i < num_args; i++)
+  {
+      if (m_util.is_bv_add(args[i]))
+      {
+          return BR_FAILED;
+      }
+
+  }
+
+  vector<expr *> flat_args; // To capture all concat arguments
+  for (unsigned i = 0; i < num_args; i++)
+  {
+      flat_args.push_back(args[i]);
+  }
+
+  int flat_args_size = flat_args.size();
+
+  if (flat_args_size < 4)
+      return BR_FAILED;
+
+  // Every bvarg should be a concat of zeroes and partial products
+  for (unsigned i = 0; i < flat_args_size; i++) {
+      app *cur_add_arg = to_app(flat_args[i]); // current bvadd arg
+      // Every bvarg should be concat
+      if(!m_util.is_concat(cur_add_arg))
+          return BR_FAILED;
+
+      unsigned concat_arg_count =
+          to_app(cur_add_arg)->get_num_args(); // Number of concatenations
+      for (unsigned j = 0; j < concat_arg_count; j++) {
+        expr *concat_arg = to_app(cur_add_arg)->get_arg(j);
+        // Every concat arg should be zero or a bvmul
+        if (!is_zero(concat_arg)  && !m_util.is_bv_mul(concat_arg)) {
+            return BR_FAILED;
+        }
+      }
+  }
+
+  // Code to check feasible number of zeros in every bvadd argument
+
+  app *first_arg = to_app(flat_args[0]); // first bvadd argument
+  unsigned arg_count = to_app(first_arg)->get_num_args();
+  unsigned bvadd_arg_size = get_bv_size(first_arg);
+  unsigned pp_bv_size = 0;
+
+  // Code to get bv size of partial product
+  for (unsigned i = 0; i < arg_count; i++) {
+      expr *concat_arg = to_app(first_arg)->get_arg(i);
+      if (m_util.is_bv_mul(concat_arg)) {
+        pp_bv_size = get_bv_size(concat_arg);
+        break;
+      }
+  }
+
+  // Partial product size should be even as equal number of zeros have to be appended
+  if (pp_bv_size % 2 == 1)
+      return BR_FAILED;
+
+  unsigned const pp_bv_size_half = pp_bv_size/2;
+
+  // Check bv sizes of all partial products and zeros
+
+  for (unsigned i = 0; i < flat_args_size; i++) {
+      app *cur_add_arg = to_app(flat_args[i]); // current bvadd arg
+      unsigned concat_arg_count =
+          to_app(cur_add_arg)->get_num_args(); // Number of concatenations
+      for (unsigned j = 0; j < concat_arg_count; j++) {
+        expr *concat_arg = to_app(cur_add_arg)->get_arg(j);
+        if (is_zero(concat_arg)) {
+          unsigned zero_count = get_bv_size(concat_arg);
+          // Number of zeros should always be a multiple of pp_bv_size_half
+          if (zero_count % pp_bv_size_half != 0)
+              return BR_FAILED;
+        }
+
+        // If mul, check if it is same size as captured before
+        // and if each bvmul has enough padding
+        else if (m_util.is_bv_mul(concat_arg)) {
+          unsigned pp_size = get_bv_size(concat_arg);
+          // All partial product sizes should be equal
+          if (pp_size != pp_bv_size)
+              return BR_FAILED;
+          // Check for whether first half of each bvmul arg is zero
+          unsigned bvmul_arg_count =
+              to_app(concat_arg)->get_num_args();
+          if (bvmul_arg_count != 2)
+              return BR_FAILED;
+          for (unsigned i = 0; i < bvmul_arg_count; i++)
+          {
+              expr *bvmul_arg = to_app(concat_arg)->get_arg(i);
+              unsigned sz = get_bv_size(bvmul_arg);
+
+              for (unsigned j = sz/2; j < sz; j++) {
+                  if (!is_zero_bit(bvmul_arg, j))
+                  {
+                      // bad state;
+                      return BR_FAILED;
+                  }
+              }
+          }
+        }
+      }
+  }
+
+
+  /* Now that we know all args have right number of zeros,
+     and same pp bv size, we go through each bvadd arg at a time
+     and collect them in appropriate container
+     */
+
+  vector<expr *> container[50];  // Containers to capture all bvmul args
+
+  for (unsigned i = 0; i < flat_args_size; i++) {
+    app *cur_add_arg = to_app(flat_args[i]); // current bvadd arg
+
+    unsigned concat_arg_count =
+        to_app(cur_add_arg)->get_num_args(); // Number of concatenations
+
+    int pos_count = 0;
+    // Collect all partial products in appropriate container
+    for (unsigned j = 0; j < concat_arg_count; j++) {
+      expr *concat_arg = to_app(cur_add_arg)->get_arg(j);
+
+      // If zero, do nothing, just count position
+      if (is_zero(concat_arg)) {
+        pos_count += get_bv_size(concat_arg);
+      }
+
+      // If mul, collect bvmul in appropriate container
+      else if (m_util.is_bv_mul(concat_arg)) {
+        container[(pos_count / pp_bv_size_half)+1].push_back(
+            to_app(concat_arg));
+        pos_count += get_bv_size(concat_arg);
+      }
+    }
+  }
+
+
+  const unsigned no_of_containers = bvadd_arg_size/pp_bv_size_half;
+  unsigned size;
+
+  // Check max size of containers
+
+  for (unsigned i = 0; i < no_of_containers/2; i++) {
+      size = container[i].size();
+      if (size > i)
+          return BR_FAILED;
+  }
+
+  for (unsigned i = no_of_containers/2; i < no_of_containers; i++) {
+      size = container[i].size();
+      if (size > no_of_containers - i)
+          return BR_FAILED;
+  }
+
+  // Look for the first non empty container
+  unsigned i;
+  for (i = 0; i < no_of_containers; i++)
+  {
+      size = container[i].size();
+      if (size != 0)
+      {
+          break;
+      }
+  }
+
+  if (container[i].size() != 1 || i >= no_of_containers)
+      return BR_FAILED;
+
+  unsigned first_non_empty_container_index = i;
+
+  /* Now that we know the first non empty container, and that it has only
+   * partial product, lets see if both the arguments are same
+   */
+
+  expr *bvmul = container[first_non_empty_container_index][0];
+  expr *bvmul_arg1 = to_app(bvmul)->get_arg(0);
+  expr *bvmul_arg2 = to_app(bvmul)->get_arg(1);
+
+  // bool same_first_args;
+
+  /*
+  if (bvmul_arg1 == bvmul_arg2)
+      same_first_args = true;
+  else
+      same_first_args = false;
+  */
+
+  vector<expr *> left_container; // To capture all lhs arguments
+  vector<expr *> right_container; // To capture all rhs arguments
+
+  vector<vector<expr *> >(left_container_list).swap(left_container_list);
+  vector<vector<expr *> >(right_container_list).swap(right_container_list);
+
+  left_container.push_back(to_app(bvmul_arg1));
+  right_container.push_back(to_app(bvmul_arg2));
+
+  bool check = check_container(no_of_containers,
+                               first_non_empty_container_index,
+                               first_non_empty_container_index+1,
+                               container,
+                               left_container,
+                               right_container
+                               );
+
+  if (!check)
+      return BR_FAILED;
+
+  for (unsigned j = 0; j < left_container_list.size(); j++)
+  {
+      left_container = left_container_list[j];
+      right_container = right_container_list[j];
+      unsigned const left_container_size = left_container.size();
+      unsigned const right_container_size = right_container.size();
+
+      // Should be equal as insertions have been done for both at every point
+      if (left_container_size != right_container_size)
+          return BR_FAILED;
+
+      // TODO - check whether both the below strips need to be done
+      // together.
+
+      // Strip off extra zero args from the right
+      for (signed i = left_container_size - 1; i >= 0; i--)
+      {
+          if (is_zero(left_container[i]))
+          {
+              left_container.erase(left_container.begin() + i);
+          }
+
+          else
+          {
+              break;
+          }
+      }
+
+
+      for (signed i = right_container_size - 1; i >= 0; i--)
+      {
+          if (is_zero(right_container[i]))
+          {
+              right_container.erase(right_container.begin() + i);
+          }
+
+          else
+          {
+              break;
+          }
+      }
+
+
+
+      // Code to reconstruct the multiplicand and multiplier
+      // Find the number of empty containers on the right
+      unsigned no_of_empty_containers_right = 0;
+
+      for (signed i = no_of_containers - 1; i >= 0; i--)
+      {
+          if (container[i].size() == 0)
+          {
+              no_of_empty_containers_right++;
+          }
+
+          else
+              break;
+      }
+
+      // Calculate number of trailing and leading zero args in m1 and m2
+
+      unsigned const no_of_args = no_of_containers/2;
+      unsigned m1_trailing_zero, m2_trailing_zero;
+      int flag;
+      for (unsigned i = 0; i <= no_of_args; i++)
+      {
+          flag = 0;
+          for (unsigned j = 0; j <= no_of_args; j++)
+          {
+              if((left_container.size() + i <= no_of_args) &&
+                 (right_container.size() + j <= no_of_args) &&
+                 ((i+j) == no_of_empty_containers_right))
+              {
+                  m1_trailing_zero = i;
+                  m2_trailing_zero = j;
+                  flag = 1;
+                  break;
+              }
+          }
+
+          if (flag == 1)
+              break;
+      }
+
+      if (flag == 0)
+          continue;
+
+      unsigned m1_leading_zero = no_of_args - left_container.size() - m1_trailing_zero;
+      unsigned m2_leading_zero = no_of_args - right_container.size() - m2_trailing_zero;
+
+
+      // Code to add front zero padding
+      unsigned number_of_front_zeros = pp_bv_size_half * no_of_args;
+      expr * zero_padding = m_util.mk_numeral(numeral(0), number_of_front_zeros);
+
+      vector<expr *> m1;
+      vector<expr *> m2;
+
+      m1.push_back(zero_padding);
+      m2.push_back(zero_padding);
+
+      // Code to add leading zeros
+
+      expr * zero = m_util.mk_numeral(numeral(0), pp_bv_size_half);
+
+      for (unsigned i = 0; i < m1_leading_zero; i++)
+          m1.push_back(zero);
+      for (unsigned i = 0; i < m2_leading_zero; i++)
+          m2.push_back(zero);
+
+      // Code to add m1 and m2 found
+      for (unsigned i = 0; i < left_container.size(); i++)
+      {
+          m1.push_back(m_mk_extract(pp_bv_size_half-1, 0, left_container[i]));
+      }
+
+      for (unsigned i = 0; i < right_container.size(); i++)
+      {
+          m2.push_back(m_mk_extract(pp_bv_size_half-1, 0, right_container[i]));
+      }
+
+      // Code to add trailing zeros
+
+      for (unsigned i = 0; i < m1_trailing_zero; i++)
+          m1.push_back(zero);
+      for (unsigned i = 0; i < m2_trailing_zero; i++)
+          m2.push_back(zero);
+
+      expr *const *l = &m1[0];
+      expr *const *r = &m2[0];
+
+      expr* concat1 = m_util.mk_concat(m1.size(),l);
+      expr* concat2 = m_util.mk_concat(m2.size(),r);
+
+      expr* mul_args[2] = {concat1,concat2};
+      expr *e1 = m().mk_app(get_fid(), OP_BADD, num_args, args);
+      expr *e2 = m().mk_app(get_fid(), OP_BMUL, 2, mul_args);
+      expr *e3 = m().mk_eq(e1, e2);
+      m().inc_ref(e3);
+      returned_axiom -> push_back(e3);
+
+      result = m().mk_eq(e1, e2);
+      tout << "\n; Adding new assert\n";
+      tout << "(assert";
+      tout << result;
+      tout << ")";
+      tout << "\n\n";
+  }
+
+  return BR_FAILED;
+
+  }
+
+int bv_rewriter::check_container(unsigned const no_of_containers,
+                                 unsigned const first_non_empty_container_index,
+                                 unsigned const current_container_index,
+                                 vector<expr *> const (&container)[50],
+                                 vector<expr *> &left_container,
+                                 vector<expr *> &right_container) {
+    // Create a copy of the current container
+
+    if (current_container_index == no_of_containers)
+    {
+        vector<expr *> left_container_copy(left_container);
+        vector<expr *> right_container_copy(right_container);
+        left_container_list.push_back(left_container_copy);
+        right_container_list.push_back(right_container_copy);
+        return 1;
+    }
+
+    vector<expr *> current_container(container[current_container_index]);
+    unsigned int offset = current_container_index - first_non_empty_container_index;
+    unsigned int sz = current_container.size();
+
+    // Remove known partial products from current container
+    for (unsigned i = 1; i <= offset - 1; i++)
+    {
+        expr * l = left_container[i];
+        expr * r = right_container[offset - i];
+
+        unsigned sz = current_container.size();
+
+        if (!is_zero(l) && !is_zero(r))
+        {
+            unsigned flag = 0;
+            for (unsigned j = 0; j < sz; j++)
+            {
+                expr *bvmul = current_container[j];
+                expr *bvmul_arg1 = to_app(bvmul)->get_arg(0);
+                expr *bvmul_arg2 = to_app(bvmul)->get_arg(1);
+
+                if ((l == bvmul_arg1 && r == bvmul_arg2) ||
+                        (l == bvmul_arg2 && r == bvmul_arg1))
+                {
+                    flag = 1;
+                    current_container.erase(current_container.begin() + j);
+                    break;
+                }
+            }
+
+            if (flag == 0)
+                return 0;
+        }
+    }
+
+    // At max two partial products should remain after removing known ones
+    if (current_container.size() > 2)
+    {
+        return 0;
+    }
+
+    sz = current_container.size();
+
+    // Now we look at the different cases based on first argument collected
+    // and the partial products in the current container
+
+    bool const same_first_args = (left_container[0] == right_container[0]);
+    expr * zero = m_util.mk_numeral(numeral(0), get_bv_size(left_container[0]));
+
+    // Case 1: first arguments are different and current container has 2 pps
+    if (!same_first_args && sz == 2)
+    {
+        expr *bvmul1 = current_container[0];
+        expr *bvmul2 = current_container[1];
+        expr *l1 = to_app(bvmul1)->get_arg(0);
+        expr *r1 = to_app(bvmul1)->get_arg(1);
+        expr *l2 = to_app(bvmul2)->get_arg(0);
+        expr *r2 = to_app(bvmul2)->get_arg(1);
+
+        vector<expr *> left_container_copy(left_container);
+        vector<expr *> right_container_copy(right_container);
+
+        // Check whether both first arguments are present in the pps
+
+        bool present = false;
+
+        if (l1 == left_container[0] || r1 == left_container[0])
+        {
+            if (l2 == right_container[0] || r2 == right_container[0])
+            {
+                present = true;
+            }
+        }
+
+        if (l1 == right_container[0] || r1 == right_container[0])
+        {
+            if (l2 == left_container[0] || r2 == left_container[0])
+            {
+                present = true;
+            }
+        }
+
+        // Both first arguments not found
+        if (!present)
+        {
+            return 0;
+        }
+
+        // Now we know both first arguments are present in both the partial
+        // products. We can now look at different subcases
+
+        // Subcase 1: left_container[0] is an argument of bvmul1 and not bvmul2
+
+        if ((l1 == left_container[0] || r1 == left_container[0]) &&
+                !(l2 == left_container[0] || r2 == left_container[0]))
+        {
+            if (l1 == left_container[0])
+                right_container.push_back(to_app(r1));
+            else if (r1 == left_container[0])
+                right_container.push_back(to_app(l1));
+
+            if (l2 == right_container[0])
+                left_container.push_back(to_app(r2));
+            else if (r2 == right_container[0])
+                left_container.push_back(to_app(l2));
+        }
+
+        // Subcase 2: left_container[0] is an argument of bvmul2 and not bvmul1
+
+        else if ((l2 == left_container[0] || r2 == left_container[0]) &&
+                !(l1 == left_container[0] || r1 == left_container[0]))
+        {
+            if (l2 == left_container[0])
+                right_container.push_back(to_app(r2));
+            else if (r2 == left_container[0])
+                right_container.push_back(to_app(l2));
+
+            if (l1 == right_container[0])
+                left_container.push_back(to_app(r1));
+            else if (r1 == right_container[0])
+                left_container.push_back(to_app(l1));
+        }
+
+        // Subcase 3: right_container[0] is an argument of bvmul1 and not bvmul2
+
+        else if ((l1 == right_container[0] || r1 == right_container[0]) &&
+                !(l2 == right_container[0] || r2 == right_container[0]))
+        {
+            if (l1 == right_container[0])
+                left_container.push_back(to_app(r1));
+            else if (r1 == right_container[0])
+                left_container.push_back(to_app(l1));
+
+            if (l2 == left_container[0])
+                right_container.push_back(to_app(r2));
+            else if (r2 == left_container[0])
+                right_container.push_back(to_app(l2));
+        }
+
+        // Subcase 4: right_container[0] is an argument of bvmul2 and not bvmul1
+
+        else if ((l2 == right_container[0] || r2 == right_container[0]) &&
+                !(l1 == right_container[0] || r1 == right_container[0]))
+        {
+            if (l2 == right_container[0])
+                left_container.push_back(to_app(r2));
+            else if (r2 == right_container[0])
+                left_container.push_back(to_app(l2));
+
+            if (l1 == left_container[0])
+                right_container.push_back(to_app(r1));
+            else if (r1 == left_container[0])
+                right_container.push_back(to_app(l1));
+        }
+
+        // Subcase 5: Both first arguments are present in both bvmul1 and bvmul2
+        // if a and b are the first arguments, bvmul1 and bvmul2 are both a * b
+
+        else if ((l1 == left_container[0] || r1 == left_container[0]) &&
+                 (l2 == left_container[0] || r2 == left_container[0]) &&
+                 (l2 == right_container[0] || r2 == right_container[0]) &&
+                 (l1 == right_container[0] || r1 == right_container[0]))
+        {
+            left_container.push_back(left_container[0]);
+            right_container.push_back(right_container[0]);
+        }
+
+        bool check = check_container(no_of_containers,
+                                     first_non_empty_container_index,
+                                     current_container_index+1,
+                                     container,
+                                     left_container,
+                                     right_container
+                                     );
+        if (check)
+            return 1;
+        else
+        {
+            left_container = left_container_copy;
+            right_container = right_container_copy;
+            return 0;
+        }
+
+    }
+
+    // Case 2: first arguments are same and current container has 2 pps
+    else if (same_first_args && sz == 2)
+    {
+        expr *bvmul1 = current_container[0];
+        expr *bvmul2 = current_container[1];
+        expr *l1 = to_app(bvmul1)->get_arg(0);
+        expr *r1 = to_app(bvmul1)->get_arg(1);
+        expr *l2 = to_app(bvmul2)->get_arg(0);
+        expr *r2 = to_app(bvmul2)->get_arg(1);
+
+        // Check whether first argument is present in both bvmuls
+
+        bool present = false;
+
+        if (l1 == left_container[0] || r1 == left_container[0])
+        {
+            if (l2 == left_container[0] || r2 == left_container[0])
+            {
+                present = true;
+            }
+        }
+
+        // First argument not present in both bvmuls
+        if (!present)
+        {
+            return 0;
+        }
+
+        // Subcase 1
+        if (l1 == left_container[0] && l2 == left_container[0])
+        {
+            vector<expr *> left_container_copy(left_container);
+            vector<expr *> right_container_copy(right_container);
+            left_container.push_back(r1);
+            right_container.push_back(r2);
+
+            bool check1 = check_container(no_of_containers,
+                                         first_non_empty_container_index,
+                                         current_container_index+1,
+                                         container,
+                                         left_container,
+                                         right_container
+                                         );
+            if (false)
+                return 1;
+            else
+            {
+                left_container = left_container_copy;
+                right_container = right_container_copy;
+                left_container.push_back(r2);
+                right_container.push_back(r1);
+                bool check2 = check_container(no_of_containers,
+                                             first_non_empty_container_index,
+                                             current_container_index+1,
+                                             container,
+                                             left_container,
+                                             right_container
+                                             );
+                if (check1 || check2)
+                    return 1;
+                else
+                {
+                    left_container = left_container_copy;
+                    right_container = right_container_copy;
+                    return 0;
+                }
+
+            }
+        }
+
+        // Subcase 2
+        else if (r1 == left_container[0] && r2 == left_container[0])
+        {
+            vector<expr *> left_container_copy(left_container);
+            vector<expr *> right_container_copy(right_container);
+            left_container.push_back(l1);
+            right_container.push_back(l2);
+
+            bool check1 = check_container(no_of_containers,
+                                         first_non_empty_container_index,
+                                         current_container_index+1,
+                                         container,
+                                         left_container,
+                                         right_container
+                                         );
+            if (false)
+                return 1;
+            else
+            {
+                left_container = left_container_copy;
+                right_container = right_container_copy;
+                left_container.push_back(l2);
+                right_container.push_back(l1);
+                bool check2 = check_container(no_of_containers,
+                                             first_non_empty_container_index,
+                                             current_container_index+1,
+                                             container,
+                                             left_container,
+                                             right_container
+                                             );
+                if (check1 || check2)
+                    return 1;
+                else
+                {
+                    left_container = left_container_copy;
+                    right_container = right_container_copy;
+                    return 0;
+                }
+
+            }
+        }
+
+        // Subcase 3
+        else if (l1 == left_container[0] && r2 == left_container[0])
+        {
+            vector<expr *> left_container_copy(left_container);
+            vector<expr *> right_container_copy(right_container);
+            left_container.push_back(l2);
+            right_container.push_back(r1);
+
+            bool check1 = check_container(no_of_containers,
+                                         first_non_empty_container_index,
+                                         current_container_index+1,
+                                         container,
+                                         left_container,
+                                         right_container
+                                         );
+            if (false)
+                return 1;
+            else
+            {
+                left_container = left_container_copy;
+                right_container = right_container_copy;
+                left_container.push_back(r1);
+                right_container.push_back(l2);
+                bool check2 = check_container(no_of_containers,
+                                             first_non_empty_container_index,
+                                             current_container_index+1,
+                                             container,
+                                             left_container,
+                                             right_container
+                                             );
+                if (check1 || check2)
+                    return 1;
+                else
+                {
+                    left_container = left_container_copy;
+                    right_container = right_container_copy;
+                    return 0;
+                }
+
+            }
+        }
+
+        // Subcase 4
+        else if (r1 == left_container[0] && l2 == left_container[0])
+        {
+            vector<expr *> left_container_copy(left_container);
+            vector<expr *> right_container_copy(right_container);
+            left_container.push_back(l1);
+            right_container.push_back(r2);
+
+            bool check1 = check_container(no_of_containers,
+                                         first_non_empty_container_index,
+                                         current_container_index+1,
+                                         container,
+                                         left_container,
+                                         right_container
+                                         );
+            if (false)
+                return 1;
+            else
+            {
+                left_container = left_container_copy;
+                right_container = right_container_copy;
+                left_container.push_back(r2);
+                right_container.push_back(l1);
+                bool check2 = check_container(no_of_containers,
+                                             first_non_empty_container_index,
+                                             current_container_index+1,
+                                             container,
+                                             left_container,
+                                             right_container
+                                             );
+                if (check1 || check2)
+                    return 1;
+                else
+                {
+                    left_container = left_container_copy;
+                    right_container = right_container_copy;
+                    return 0;
+                }
+
+            }
+        }
+    }
+
+    // Case 3: first arguments are different and current container has 1 pps
+    else if (!same_first_args && sz == 1)
+    {
+        expr *bvmul = current_container[0];
+        expr *l = to_app(bvmul)->get_arg(0);
+        expr *r = to_app(bvmul)->get_arg(1);
+
+        // Check whether any one of the first arguments is present in bvmul
+        if (!(l == left_container[0] || r == left_container[0] ||
+              l == right_container[0] || r == right_container[0]))
+            return 0;
+
+        // Subcase 1: Both bvmul args are first arguments
+
+        if ((l == left_container[0] && r == right_container[0]) ||
+            (r == left_container[0] && l == right_container[0]))
+        {
+            if (l == left_container[0] && r == right_container[0])
+            {
+                vector<expr *> left_container_copy(left_container);
+                vector<expr *> right_container_copy(right_container);
+                left_container.push_back(l);
+                right_container.push_back(zero);
+
+                bool check1 = check_container(no_of_containers,
+                                             first_non_empty_container_index,
+                                             current_container_index+1,
+                                             container,
+                                             left_container,
+                                             right_container
+                                             );
+                if (false)
+                    return 1;
+                else
+                {
+                    left_container = left_container_copy;
+                    right_container = right_container_copy;
+                    left_container.push_back(zero);
+                    right_container.push_back(r);
+                    bool check2 = check_container(no_of_containers,
+                                                 first_non_empty_container_index,
+                                                 current_container_index+1,
+                                                 container,
+                                                 left_container,
+                                                 right_container
+                                                 );
+                    if (check1 || check2)
+                        return 1;
+                    else
+                    {
+                        left_container = left_container_copy;
+                        right_container = right_container_copy;
+                        return 0;
+                    }
+                }
+            }
+
+            else if (r == left_container[0] && l == right_container[0])
+            {
+                vector<expr *> left_container_copy(left_container);
+                vector<expr *> right_container_copy(right_container);
+                left_container.push_back(r);
+                right_container.push_back(zero);
+
+                bool check1 = check_container(no_of_containers,
+                                             first_non_empty_container_index,
+                                             current_container_index+1,
+                                             container,
+                                             left_container,
+                                             right_container
+                                             );
+                if (false)
+                    return 1;
+                else
+                {
+                    left_container = left_container_copy;
+                    right_container = right_container_copy;
+                    left_container.push_back(zero);
+                    right_container.push_back(l);
+                    bool check2 = check_container(no_of_containers,
+                                                 first_non_empty_container_index,
+                                                 current_container_index+1,
+                                                 container,
+                                                 left_container,
+                                                 right_container
+                                                 );
+                    if (check1 || check2)
+                        return 1;
+                    else
+                    {
+                        left_container = left_container_copy;
+                        right_container = right_container_copy;
+                        return 0;
+                    }
+
+                }
+            }
+
+        }
+
+        // Subcase 2: Only one bvmul arg is first argument
+        else
+        {
+            vector<expr *> left_container_copy(left_container);
+            vector<expr *> right_container_copy(right_container);
+
+            if (l == left_container[0])
+            {
+            left_container.push_back(zero);
+            right_container.push_back(r);
+            }
+
+            else if (r == left_container[0])
+            {
+            left_container.push_back(zero);
+            right_container.push_back(l);
+            }
+
+            else if (l == right_container[0])
+            {
+            left_container.push_back(r);
+            right_container.push_back(zero);
+            }
+
+            else if (r == right_container[0])
+            {
+            left_container.push_back(l);
+            right_container.push_back(zero);
+            }
+
+            bool check = check_container(no_of_containers,
+                                         first_non_empty_container_index,
+                                         current_container_index+1,
+                                         container,
+                                         left_container,
+                                         right_container
+                                         );
+            if (check)
+                return 1;
+            else
+            {
+                left_container = left_container_copy;
+                right_container = right_container_copy;
+                return 0;
+            }
+        }
+
+    }
+
+    // Case 4: first arguments are same and current container has 1 pps
+    else if (same_first_args && sz == 1)
+    {
+        expr *bvmul = current_container[0];
+        expr *l = to_app(bvmul)->get_arg(0);
+        expr *r = to_app(bvmul)->get_arg(1);
+
+        // Check whether first argument is present in bvmul
+        if (!(l == left_container[0] || r == left_container[0]))
+            return 0;
+
+        if (l == left_container[0])
+        {
+            vector<expr *> left_container_copy(left_container);
+            vector<expr *> right_container_copy(right_container);
+            left_container.push_back(r);
+            right_container.push_back(zero);
+
+            bool check1 = check_container(no_of_containers,
+                                         first_non_empty_container_index,
+                                         current_container_index+1,
+                                         container,
+                                         left_container,
+                                         right_container
+                                         );
+            if (false)
+                return 1;
+            else
+            {
+                left_container = left_container_copy;
+                right_container = right_container_copy;
+                left_container.push_back(zero);
+                right_container.push_back(r);
+                bool check2 = check_container(no_of_containers,
+                                             first_non_empty_container_index,
+                                             current_container_index+1,
+                                             container,
+                                             left_container,
+                                             right_container
+                                             );
+                if (check1 || check2)
+                    return 1;
+                else
+                {
+                    left_container = left_container_copy;
+                    right_container = right_container_copy;
+                    return 0;
+                }
+            }
+        }
+
+        else if (r == left_container[0])
+        {
+            vector<expr *> left_container_copy(left_container);
+            vector<expr *> right_container_copy(right_container);
+            left_container.push_back(l);
+            right_container.push_back(zero);
+
+            bool check1 = check_container(no_of_containers,
+                                         first_non_empty_container_index,
+                                         current_container_index+1,
+                                         container,
+                                         left_container,
+                                         right_container
+                                         );
+            if (false)
+                return 1;
+            else
+            {
+                left_container = left_container_copy;
+                right_container = right_container_copy;
+                right_container.push_back(l);
+                left_container.push_back(zero);
+                bool check2 = check_container(no_of_containers,
+                                             first_non_empty_container_index,
+                                             current_container_index+1,
+                                             container,
+                                             left_container,
+                                             right_container
+                                             );
+                if (check1 || check2)
+                    return 1;
+                else
+                {
+                    left_container = left_container_copy;
+                    right_container = right_container_copy;
+                    return 0;
+                }
+
+            }
+        }
+    }
+
+    // Case 5: current container has 0 pps
+    else if (sz == 0)
+    {
+        vector<expr *> left_container_copy(left_container);
+        vector<expr *> right_container_copy(right_container);
+
+        left_container.push_back(zero);
+        right_container.push_back(zero);
+        bool check = check_container(no_of_containers,
+                                     first_non_empty_container_index,
+                                     current_container_index+1,
+                                     container,
+                                     left_container,
+                                     right_container
+                                     );
+        if (check)
+            return 1;
+        else
+        {
+            left_container = left_container_copy;
+            right_container = right_container_copy;
+            return 0;
+        }
+    }
+
+
+    return 0;
+}
+
+int bv_rewriter::extract_initial_bits(expr * const arg, unsigned const index, vector<expr *> (&container)[50]) {
+
+    unsigned const arg_size = get_bv_size(arg);
+    if (is_zero_bit(arg, index))
+    {
+        container[arg_size - 1 - index].push_back(mk_numeral(0, 1));
+        return 1;
+    }
+
+    if (m_util.is_concat(arg))
+    {
+        unsigned count = 0;
+        unsigned no_of_args = to_app(arg)->get_num_args();
+
+        for (unsigned i = 0; i < no_of_args; i++)
+        {
+            expr *cur_concat_arg = to_app(arg)->get_arg(i);
+            if (arg_size - 1 - index >= count + get_bv_size(cur_concat_arg))
+            {
+                count += get_bv_size(cur_concat_arg);
+            }
+
+            else if (arg_size - 1 - index == count && get_bv_size(cur_concat_arg) == 1)
+            {
+                container[arg_size - 1 - index].push_back(cur_concat_arg);
+                return 1;
+            }
+
+            else
+            {
+                unsigned new_index = arg_size - 1 - index - count;
+                if (m_util.is_bv_not(cur_concat_arg))
+                {
+                    expr *not_arg = to_app(cur_concat_arg)->get_arg(0);
+                    if (m_util.is_bv_or(not_arg))
+                    {
+                        expr *or_arg1 = to_app(not_arg)->get_arg(0);
+                        expr *or_arg2 = to_app(not_arg)->get_arg(1);
+
+                        if (!m_util.is_concat(or_arg1) || !m_util.is_concat(or_arg2))
+                        {
+                            return 0;
+                        }
+
+                        else
+                        {
+                            if (to_app(or_arg1)->get_num_args() == get_bv_size(or_arg1))
+                            {
+                                if (to_app(or_arg2)->get_num_args() == get_bv_size(or_arg2))
+                                {
+                                    expr *e1 = to_app(or_arg1)->get_arg(new_index);
+                                    expr *e2 = to_app(or_arg2)->get_arg(new_index);
+
+                                    if (is_numeral(e1) && !is_zero(e1))
+                                    {
+                                        if (is_numeral(e2) && !is_zero(e2))
+                                        {
+                                            container[arg_size - 1 - index].push_back(mk_numeral(0, 1));
+                                            return 1;
+                                        }
+                                    }
+
+                                    else if (m_util.is_bv_not(e1) && m_util.is_bv_not(e2))
+                                    {
+                                        vector<expr *> new_args;
+                                        new_args.push_back(e1);
+                                        new_args.push_back(e2);
+                                        expr *e3 = m_util.mk_bv_or(new_args.size(), new_args.c_ptr());
+                                        //expr* or_args[2] = {e1,e2};
+                                        //expr *e3 = m_util.mk_bv_or(2, or_args);
+                                        container[arg_size - 1 - index].push_back(m_util.mk_bv_not(e3));
+                                        return 1;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    else if (m_util.is_bv_not(arg))
+    {
+        expr *not_arg = to_app(arg)->get_arg(0);
+        if (m_util.is_bv_or(not_arg))
+        {
+            expr *or_arg1 = to_app(not_arg)->get_arg(0);
+            expr *or_arg2 = to_app(not_arg)->get_arg(1);
+
+            if (!m_util.is_concat(or_arg1) || !m_util.is_concat(or_arg2))
+            {
+                return 0;
+            }
+
+            else
+            {
+                unsigned new_index = arg_size - 1 - index;
+                if (to_app(or_arg1)->get_num_args() == get_bv_size(or_arg1))
+                {
+                    if (to_app(or_arg2)->get_num_args() == get_bv_size(or_arg2))
+                    {
+                        expr *e1 = to_app(or_arg1)->get_arg(new_index);
+                        expr *e2 = to_app(or_arg2)->get_arg(new_index);
+
+                        if (is_numeral(e1) && !is_zero(e1))
+                        {
+                            if (is_numeral(e2) && !is_zero(e2))
+                            {
+                                container[arg_size - 1 - index].push_back(mk_numeral(0, 1));
+                                return 1;
+                            }
+                        }
+
+                        else if (e1 == e2)
+                        {
+                            if (m_util.is_bv_not(e1) && m_util.is_bv_not(e2))
+                            {
+                                expr *e3 = to_app(e1)->get_arg(0);
+                                container[arg_size - 1 - index].push_back(e3);
+                                return 1;
+                            }
+                            container[arg_size - 1 - index].push_back(m_util.mk_bv_not(e1));
+                            return 1;
+                        }
+
+                        else if (m_util.is_bv_not(e1) && m_util.is_bv_not(e2))
+                        {
+                            ptr_buffer<expr> new_args;
+                            new_args.push_back(e1);
+                            new_args.push_back(e2);
+                            expr *e3 = m_util.mk_bv_or(new_args.size(), new_args.c_ptr());
+                            container[arg_size - 1 - index].push_back(m_util.mk_bv_not(e3));
+                            return 1;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    return 0;
+}
+
+int bv_rewriter::check_xor(expr *const arg, expr *& a, expr *& b)
+{
+    if (m_util.is_bv_not(arg))
+    {
+        expr *not_arg = to_app(arg)->get_arg(0);
+        if (m_util.is_bv_or(not_arg) && to_app(not_arg)->get_num_args() == 2)
+        {
+            expr *or_arg1 = to_app(not_arg)->get_arg(0);
+            expr *or_arg2 = to_app(not_arg)->get_arg(1);
+
+            if (m_util.is_bv_not(or_arg1) && m_util.is_bv_not(or_arg2))
+            {
+                expr *not_arg1 = to_app(or_arg1)->get_arg(0);
+                expr *not_arg2 = to_app(or_arg2)->get_arg(0);
+
+                if (m_util.is_bv_or(not_arg1) && m_util.is_bv_or(not_arg2))
+                {
+                    if(to_app(not_arg2)->get_num_args() > 2)
+                    {
+                        if(to_app(not_arg1)->get_num_args() == 2)
+                        {
+                            expr *temp = not_arg1;
+                            not_arg1 = not_arg2;
+                            not_arg2 = temp;
+                        }
+                    }
+
+                    if(to_app(not_arg1)->get_num_args() > 2)
+                    {
+                        if(to_app(not_arg2)->get_num_args() == 2)
+                        {
+                            expr *or_arg1 = to_app(not_arg2)->get_arg(0);
+                            expr *or_arg2 = to_app(not_arg2)->get_arg(1);
+                            a = or_arg1;
+                            b = or_arg2;
+                            return 1;
+                            // TODO - Check other not_arg1 for correctness
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    else if (m().is_ite(arg))
+    {
+        expr * ite_arg = to_app(arg)->get_arg(0);
+        expr * eq_arg1 = to_app(ite_arg)->get_arg(0);
+        expr * eq_arg2 = to_app(ite_arg)->get_arg(1);
+
+        if (m_util.is_bv_not(eq_arg1))
+        {
+            if (m_util.is_bv_not(eq_arg2))
+            {
+                expr *e1 = to_app(eq_arg1)->get_arg(0);
+
+                if (m_util.is_bv_or(e1) && to_app(e1)->get_num_args() == 2)
+                {
+                    a = eq_arg1;
+                    b = to_app(eq_arg2)->get_arg(0);
+                }
+
+                else
+                {
+                    a = eq_arg2;
+                    b = to_app(eq_arg1)->get_arg(0);
+                }
+
+                return 1;
+            }
+        }
+
+        else if (m().is_ite(eq_arg1))
+        {
+            if (m_util.is_bv_not(eq_arg2))
+            {
+                a = eq_arg1;
+                b = to_app(eq_arg2)->get_arg(0);
+                return 1;
+            }
+        }
+
+        else if (m().is_ite(eq_arg2))
+        {
+            if (m_util.is_bv_not(eq_arg1))
+            {
+                a = eq_arg2;
+                b = to_app(eq_arg1)->get_arg(0);
+                return 1;
+            }
+        }
+
+
+    }
+
+    return 0;
+}
+
+
+int bv_rewriter::check_pp(expr * const arg) {
+
+    if (m_util.is_bv_not(arg))
+    {
+        expr *not_arg = to_app(arg)->get_arg(0);
+        if (m_util.is_bv_or(not_arg) && to_app(not_arg)->get_num_args() == 2)
+        {
+            expr *or_arg1 = to_app(not_arg)->get_arg(0);
+            expr *or_arg2 = to_app(not_arg)->get_arg(1);
+
+            if (m_util.is_bv_not(or_arg1) && m_util.is_bv_not(or_arg2))
+            {
+                expr *not_arg1 = to_app(or_arg1)->get_arg(0);
+                expr *not_arg2 = to_app(or_arg2)->get_arg(0);
+
+                if (!m_util.is_bv_not(not_arg1) && !m_util.is_bv_or(not_arg1))
+                {
+                    if (!m_util.is_bv_not(not_arg2) && !m_util.is_bv_or(not_arg2))
+                        return 1;
+                }
+
+            }
+        }
+    }
+
+    return 0;
+}
+
+int bv_rewriter::check_ha_carry(expr *const arg, expr *& a, expr *& b) {
+    if (m_util.is_bv_not(arg))
+    {
+        expr *not_arg = to_app(arg)->get_arg(0);
+        if (m_util.is_bv_or(not_arg) && to_app(not_arg)->get_num_args() >= 2)
+        {
+            bool check = true;
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
+int bv_rewriter::check_fa_carry(expr *const arg, expr *& a, expr *& b, expr *& c) {
+
+    if (m_util.is_bv_or(arg) && to_app(arg)->get_num_args() == 3)
+    {
+        bool check = true;
+        return 1;
+    }
+
+    return 0;
+}
+
+
+br_status bv_rewriter::check_wallace(unsigned num_args, expr *const *args,
+                                     expr_ref &result) {
+
+    /*
+    // Code to print add args
+    result = args[0];
+    tout << result;
+    tout << "\n\n";
+    result = args[1];
+    tout << result;
+    tout << "\n\n";
+
+    return BR_FAILED;
+    */
+
+    // add will have only two arguments if it is a wallace tree implementation
+    if (num_args != 2)
+        return BR_FAILED;
+
+
+    expr *arg1 = args[0];
+
+    unsigned const arg_size = get_bv_size(arg1);
+    vector<expr *> work_container[50];
+
+    // Extract bits of bvadd arg1
+    for (signed i = arg_size - 1; i >= 0 ; i--)
+    {
+        bool check = extract_initial_bits(arg1, i, work_container);
+        if (check == 0)
+            return BR_FAILED;
+    }
+
+    /*
+    tout << "1st argument bits\n\n";
+    // Code to print extracted bits
+
+
+    for (unsigned i = 0; i < arg_size; i++)
+    {
+        result = work_container[i][0];
+        tout << result;
+        tout << "\n\n";
+    }
+    */
+
+    expr *arg2 = args[1];
+
+    // Extract bits of bvadd arg2
+    for (signed i = arg_size - 1; i >= 0 ; i--)
+    {
+        bool check = extract_initial_bits(arg2, i, work_container);
+        if (check == 0)
+            return BR_FAILED;
+    }
+
+    /*
+    tout << "2nd argument bits\n\n";
+    // Code to print extracted bits
+
+    for (unsigned i = 0; i < arg_size; i++)
+    {
+        result = work_container[i][1];
+        tout << result;
+        tout << "\n\n";
+    }
+    */
+
+    vector<expr *> pp_container[50];
+
+    // Check
+    for (unsigned i = 0; i < arg_size; i++)
+    {
+        if (work_container[i].size() != 2)
+        {
+            return BR_FAILED;
+        }
+    }
+
+
+
+    // traverse bits of arg1 and collect partial products
+    for (unsigned i = 0; i < arg_size; i++)
+    {
+        while (!work_container[i].empty())
+        {
+            expr *a = nullptr;
+            expr *b = nullptr;
+            expr *c = nullptr;
+
+            expr *e = work_container[i][0];
+
+            if (is_zero_bit(e, 0));
+
+            else if (check_pp(e))
+            {
+                pp_container[i].push_back(e);
+            }
+
+            else if (check_xor(e, a, b))
+            {
+                work_container[i].push_back(a);
+                work_container[i].push_back(b);
+            }
+
+            else if (check_ha_carry(e, a, b))
+            {
+                bool check = true;
+            }
+
+            else if (check_fa_carry(e, a, b, c))
+            {
+                bool check = true;
+            }
+
+            else
+            {
+                bool check = false;
+            }
+
+            work_container[i].erase(work_container[i].begin());
+        }
+    }
+
+    // Check pp_container size
+    unsigned size;
+    for (unsigned i = 0; i <= arg_size/2; i++) {
+        size = pp_container[i].size();
+        if (size != i)
+            return BR_FAILED;
+    }
+
+    // Check pp_container size
+    for (unsigned i = arg_size/2 + 1; i < arg_size; i++) {
+        size = pp_container[i].size();
+        if (size != arg_size - i)
+            return BR_FAILED;
+    }
+
+    // Convert pp to mul
+    for (unsigned i = 0; i < arg_size; i++)
+    {
+        for (unsigned j = 0; j < pp_container[i].size(); j++)
+        {
+            expr *arg = pp_container[i][j];
+            expr *not_arg = to_app(arg)->get_arg(0);
+            expr *or_arg1 = to_app(not_arg)->get_arg(0);
+            expr *or_arg2 = to_app(not_arg)->get_arg(1);
+            expr *not_arg1 = to_app(or_arg1)->get_arg(0);
+            expr *not_arg2 = to_app(or_arg2)->get_arg(0);
+            expr *e3 = m_util.mk_bv_mul(not_arg1, not_arg2);
+            pp_container[i][j] = e3;
+        }
+    }
+
+    unsigned const first_non_empty_container_index = 1;
+
+    expr *bvmul = pp_container[first_non_empty_container_index][0];
+    expr *bvmul_arg1 = to_app(bvmul)->get_arg(0);
+    expr *bvmul_arg2 = to_app(bvmul)->get_arg(1);
+
+    vector<expr *> left_container; // To capture all lhs arguments
+    vector<expr *> right_container; // To capture all rhs arguments
+
+    //vector<vector<expr *> >(left_container_list).swap(left_container_list);
+    //vector<vector<expr *> >(right_container_list).swap(right_container_list);
+
+    left_container.push_back(bvmul_arg1);
+    right_container.push_back(bvmul_arg2);
+
+    bool check = check_container(arg_size,
+                                 first_non_empty_container_index,
+                                 first_non_empty_container_index+1,
+                                 pp_container,
+                                 left_container,
+                                 right_container
+                                 );
+
+    if (!check)
+        return BR_FAILED;
+
+    for (signed i = left_container.size() - 1; i >= 0; i--)
+    {
+        if (is_zero(left_container[i]) && is_zero(right_container[i]))
+        {
+            left_container.erase(left_container.begin() + i);
+            right_container.erase(right_container.begin() + i);
+        }
+        else
+        {
+            break;
+        }
+    }
+
+    expr * zero_padding = m_util.mk_numeral(numeral(0), left_container.size());
+
+    vector<expr *> m1;
+    vector<expr *> m2;
+
+    m1.push_back(zero_padding);
+    m2.push_back(zero_padding);
+
+    for (unsigned i = 0; i < left_container.size(); i++)
+    {
+        m1.push_back(left_container[i]);
+        m2.push_back(right_container[i]);
+    }
+
+    expr *const *l = &m1[0];
+    expr *const *r = &m2[0];
+
+    expr* concat1 = m_util.mk_concat(m1.size(),l);
+    expr* concat2 = m_util.mk_concat(m2.size(),r);
+
+    expr* mul_args[2] = {concat1,concat2};
+    result = m().mk_app(get_fid(), OP_BMUL, 2, mul_args);
+
+    return BR_REWRITE1;
+
+}
+
 br_status bv_rewriter::mk_bv_add(unsigned num_args, expr * const * args, expr_ref & result) {
     br_status st = mk_add_core(num_args, args, result);
     if (st != BR_FAILED && st != BR_DONE)
         return st;
+
+   st = check_pattern(num_args, args, result);
+       if (st != BR_FAILED && st != BR_DONE)
+           return st;
+
+    st = check_wallace(num_args, args, result);
+        if (st != BR_FAILED && st != BR_DONE)
+            return st;
+
+
 #if 0
     expr * x;
     expr * y;
@@ -1682,6 +3283,8 @@ br_status bv_rewriter::mk_bv_add(unsigned num_args, expr * const * args, expr_re
     }
     if (_num_args < 2)
         return st;
+
+
     unsigned sz = get_bv_size(_args[0]);
     for (unsigned i = 0; i < sz; i++) {
         bool found_non_zero = false;
diff --git a/src/ast/rewriter/bv_rewriter.h b/src/ast/rewriter/bv_rewriter.h
index 7135c52..19a7e52 100644
--- a/src/ast/rewriter/bv_rewriter.h
+++ b/src/ast/rewriter/bv_rewriter.h
@@ -89,6 +89,22 @@ class bv_rewriter : public poly_rewriter<bv_rewriter_core> {
     br_status mk_bv_ext_rotate_left(expr * arg1, expr * arg2, expr_ref & result);
     br_status mk_bv_ext_rotate_right(expr * arg1, expr * arg2, expr_ref & result);
     br_status mk_bv_add(unsigned num_args, expr * const * args, expr_ref & result);
+    br_status check_wallace(unsigned num_args, expr *const *args, expr_ref &result);
+    br_status check_pattern(unsigned num_args, expr *const *args, expr_ref &result);
+    void traverse_bvadd_args(expr * cur_arg, vector<expr *> &bv_args);
+    int check_container(const unsigned no_of_containers,
+                        const unsigned first_non_empty_container_index,
+                        const unsigned current_container_index,
+                        vector<expr *> const (&container)[50],
+                        vector<expr *> &left_container,
+                        vector<expr *> &right_container);
+    int extract_initial_bits(expr * const arg, unsigned const index, vector<expr *> (&container)[50]);
+    int check_xor(expr * const arg, expr *& a, expr *& b);
+    int check_pp(expr * const arg);
+    int check_ha_carry(expr *const arg, expr *& a, expr *& b);
+    int check_fa_carry(expr *const arg, expr *& a, expr *& b, expr *& c);
+
+
     br_status mk_bv_add(expr * arg1, expr * arg2, expr_ref & result) {
         expr * args[2] = { arg1, arg2 };
         return mk_bv_add(2, args, result);
diff --git a/src/ast/rewriter/poly_rewriter.h b/src/ast/rewriter/poly_rewriter.h
index ea0b9e8..a3a60af 100644
--- a/src/ast/rewriter/poly_rewriter.h
+++ b/src/ast/rewriter/poly_rewriter.h
@@ -159,6 +159,9 @@ public:
         expr* args[2] = { a1, a2 };
         mk_sub(2, args, result);
     }
+  //ashu-----
+  vector <expr *> *returned_axiom;
+  //ashu-----
 };
 
 
diff --git a/src/ast/rewriter/rewriter.h b/src/ast/rewriter/rewriter.h
index 44f436f..2955c24 100644
--- a/src/ast/rewriter/rewriter.h
+++ b/src/ast/rewriter/rewriter.h
@@ -118,6 +118,9 @@ public:
     void display_stack(std::ostream & out, unsigned pp_depth);
 #endif
     unsigned get_cache_size() const;
+  //ashu-----
+  vector <expr *> *returned_axiom;
+  //ashu-----
 };
 
 class var_shifter_core : public rewriter_core {
@@ -381,6 +384,9 @@ struct default_rewriter_cfg {
     bool get_subst(expr * s, expr * & t, proof * & t_pr) { return false; }
     void reset() {}
     void cleanup() {}
+  //ashu-----
+  vector <expr *> *returned_axiom;
+  //ashu-----
 };
 
 struct beta_reducer_cfg : public default_rewriter_cfg {
diff --git a/src/ast/rewriter/rewriter_def.h b/src/ast/rewriter/rewriter_def.h
index 4d55632..78b9326 100644
--- a/src/ast/rewriter/rewriter_def.h
+++ b/src/ast/rewriter/rewriter_def.h
@@ -221,6 +221,9 @@ void rewriter_tpl<Config>::process_app(app * t, frame & fr) {
                 m_pr  = m().mk_congruence(t, new_t, num_prs, result_pr_stack().c_ptr() + fr.m_spos);
             }
         }
+        //ashu-----
+        m_cfg.returned_axiom = returned_axiom;
+        //ashu-----
         br_status st = m_cfg.reduce_app(f, new_num_args, new_args, m_r, m_pr2);
         SASSERT(st != BR_DONE || m().get_sort(m_r) == m().get_sort(t));
         TRACE("reduce_app", 
diff --git a/src/ast/rewriter/th_rewriter.cpp b/src/ast/rewriter/th_rewriter.cpp
index 6f6daf8..551b139 100644
--- a/src/ast/rewriter/th_rewriter.cpp
+++ b/src/ast/rewriter/th_rewriter.cpp
@@ -157,6 +157,9 @@ struct th_rewriter_cfg : public default_rewriter_cfg {
     }
 
     br_status reduce_app_core(func_decl * f, unsigned num, expr * const * args, expr_ref & result) {
+      //ashu-----
+      m_bv_rw.returned_axiom = returned_axiom;
+      //ashu-----
         family_id fid = f->get_family_id();
         if (fid == null_family_id)
             return BR_FAILED;
@@ -764,6 +767,9 @@ void th_rewriter::operator()(expr * t, expr_ref & result) {
 }
 
 void th_rewriter::operator()(expr * t, expr_ref & result, proof_ref & result_pr) {
+  //ashu-----
+    m_imp->returned_axiom = returned_axiom;
+  //ashu-----
     m_imp->operator()(t, result, result_pr);
 }
 
diff --git a/src/ast/rewriter/th_rewriter.h b/src/ast/rewriter/th_rewriter.h
index bd5ce9c..92a18f1 100644
--- a/src/ast/rewriter/th_rewriter.h
+++ b/src/ast/rewriter/th_rewriter.h
@@ -58,6 +58,9 @@ public:
     // Remark: reset_used_dependecies will reset the internal cache if get_used_dependencies() != 0
     expr_dependency * get_used_dependencies();
     void reset_used_dependencies();
+  //ashu-----
+  vector <expr *> *returned_axiom;
+  //ashu-----
 };
 
 #endif
diff --git a/src/tactic/core/simplify_tactic.cpp b/src/tactic/core/simplify_tactic.cpp
index be89d35..65e2456 100644
--- a/src/tactic/core/simplify_tactic.cpp
+++ b/src/tactic/core/simplify_tactic.cpp
@@ -56,6 +56,10 @@ struct simplify_tactic::imp {
             if (g.inconsistent())
                 break;
             expr * curr = g.form(idx);
+            //ashu-----
+            vector <expr *> s;
+            m_r.returned_axiom = &s;
+            //ashu-----
             m_r(curr, new_curr, new_pr);
             m_num_steps += m_r.get_num_steps();
             if (g.proofs_enabled()) {
@@ -63,7 +67,16 @@ struct simplify_tactic::imp {
                 new_pr     = m().mk_modus_ponens(pr, new_pr);
             }
             g.update(idx, new_curr, new_pr, g.dep(idx));
+
+            for (unsigned i = 0; i < s.size(); i++)
+            {
+                if (s[i] != 0) {
+                    g.assert_expr(s[i]);
+                    m().dec_ref(s[i]);
+                }
+            }
         }
+
         TRACE("after_simplifier_bug", g.display(tout););
         g.elim_redundancies();
         TRACE("after_simplifier", g.display(tout););
